# DatovÃ½ model â€“ AnalÃ½za a cÃ­lovÃ½ stav

> **Verze:** 1.0.0  
> **Datum:** 2026-01-25

## Obsah

1. [PÅ™ehled](#1-pÅ™ehled)
2. [AktuÃ¡lnÃ­ stav â€“ schÃ©ma databÃ¡ze](#2-aktuÃ¡lnÃ­-stav--schÃ©ma-databÃ¡ze)
3. [ProblÃ©my aktuÃ¡lnÃ­ho stavu](#3-problÃ©my-aktuÃ¡lnÃ­ho-stavu)
4. [CÃ­lovÃ½ stav â€“ schÃ©ma databÃ¡ze](#4-cÃ­lovÃ½-stav--schÃ©ma-databÃ¡ze)
5. [Vazba na import (CSV)](#5-vazba-na-import-csv)
6. [MigraÄnÃ­ plÃ¡n](#6-migraÄnÃ­-plÃ¡n)

---

## 1. PÅ™ehled

Sazinka je systÃ©m pro sprÃ¡vu revizÃ­ plynovÃ½ch zaÅ™Ã­zenÃ­, komÃ­nÅ¯ a dalÅ¡Ã­ch technickÃ½ch zaÅ™Ã­zenÃ­. DatovÃ½ model musÃ­ podporovat:

- **ZÃ¡kaznÃ­ky** (osoby i firmy) s adresami a geokÃ³dovÃ¡nÃ­m
- **ZaÅ™Ã­zenÃ­** (kotle, komÃ­ny, krby...) s reviznÃ­m intervalem
- **ReviznÃ­ povinnosti** (periodickÃ¡ nutnost kontroly zaÅ™Ã­zenÃ­ dle zÃ¡kona)
- **NÃ¡vÅ¡tÄ›vy** (fyzickÃ© cesty k zÃ¡kaznÃ­kovi, pÅ™i kterÃ½ch se provÃ¡dÃ­ prÃ¡ce)
- **PracovnÃ­ Ãºkony** (co se pÅ™i nÃ¡vÅ¡tÄ›vÄ› konkrÃ©tnÄ› dÄ›lalo na jakÃ©m zaÅ™Ã­zenÃ­)
- **Komunikaci** (hovory, e-maily, SMS, poznÃ¡mky)
- **PosÃ¡dky** (technici/skupiny pÅ™iÅ™azenÃ© k prÃ¡ci)
- **Trasy** (dennÃ­ plÃ¡ny cest s optimalizacÃ­)

---

## 2. AktuÃ¡lnÃ­ stav â€“ schÃ©ma databÃ¡ze

### 2.1 Tabulka `users`

```
users
â”œâ”€â”€ id                              UUID PK
â”œâ”€â”€ email                           VARCHAR(255) NOT NULL UNIQUE
â”œâ”€â”€ password_hash                   VARCHAR(255) NOT NULL
â”œâ”€â”€ name                            VARCHAR(255) NOT NULL
â”œâ”€â”€ phone                           VARCHAR(50)
â”œâ”€â”€ business_name                   VARCHAR(255)
â”œâ”€â”€ street                          VARCHAR(255)
â”œâ”€â”€ city                            VARCHAR(100)
â”œâ”€â”€ postal_code                     VARCHAR(20)
â”œâ”€â”€ country                         VARCHAR(10) DEFAULT 'CZ'
â”œâ”€â”€ lat                             DOUBLE PRECISION
â”œâ”€â”€ lng                             DOUBLE PRECISION
â”œâ”€â”€ ico                             VARCHAR(20)
â”œâ”€â”€ dic                             VARCHAR(20)
â”œâ”€â”€ default_revision_interval_months INTEGER DEFAULT 12
â”œâ”€â”€ default_service_duration_minutes INTEGER DEFAULT 30
â”œâ”€â”€ working_hours_start             TIME DEFAULT '08:00'
â”œâ”€â”€ working_hours_end               TIME DEFAULT '17:00'
â”œâ”€â”€ max_revisions_per_day           INTEGER DEFAULT 12
â”œâ”€â”€ reminder_days_before            INTEGER[] DEFAULT '{30, 14, 7}'
â”œâ”€â”€ email_subject_template          TEXT
â”œâ”€â”€ email_body_template             TEXT
â”œâ”€â”€ role                            VARCHAR(20) NOT NULL DEFAULT 'customer'
â”œâ”€â”€ owner_id                        UUID REFERENCES users(id) ON DELETE CASCADE
â”œâ”€â”€ created_at                      TIMESTAMPTZ
â””â”€â”€ updated_at                      TIMESTAMPTZ
```

**Role:** `admin` (systÃ©m), `customer` (majitel firmy), `worker` (zamÄ›stnanec).
Worker mÃ¡ `owner_id` odkazujÃ­cÃ­ na svÃ©ho customera â€“ vidÃ­ stejnÃ¡ data.

**Indexy:** `idx_users_role`, `idx_users_owner`

**PoznÃ¡mky:**

| Sloupec | ProblÃ©m |
|---------|---------|
| `phone` | `VARCHAR(50)` â€“ zbyteÄnÄ› velkÃ½, E.164 max 15 ÄÃ­slic + prefix `+` = max 16 znakÅ¯. `VARCHAR(20)` staÄÃ­. |
| `country` | `VARCHAR(10)` â€“ ISO 3166-1 alpha-2 mÃ¡ vÅ¾dy 2 znaky. `CHAR(2)` by byl pÅ™esnÄ›jÅ¡Ã­. NenÃ­ kritickÃ©. |
| `default_revision_interval_months` | PatÅ™Ã­ spÃ­Å¡e do nastavenÃ­/konfigurace, ne do user tabulky. |
| `max_revisions_per_day` | NÃ¡zev neodpovÃ­dÃ¡ skuteÄnosti â€“ jde o maximum **nÃ¡vÅ¡tÄ›v** (nejen revizÃ­) za den. |
| `reminder_days_before` | PostgreSQL `INTEGER[]` â€“ je to v poÅ™Ã¡dku, ale sdÃ­lenÃ­ s frontendem je komplikovanÄ›jÅ¡Ã­. |

### 2.2 Tabulka `customers`

```
customers
â”œâ”€â”€ id                UUID PK
â”œâ”€â”€ user_id           UUID FK â†’ users NOT NULL
â”œâ”€â”€ customer_type     customer_type ENUM('person','company') DEFAULT 'person'
â”œâ”€â”€ name              VARCHAR(255) NOT NULL                â† problÃ©m
â”œâ”€â”€ contact_person    VARCHAR(255)
â”œâ”€â”€ ico               VARCHAR(20)
â”œâ”€â”€ dic               VARCHAR(20)
â”œâ”€â”€ email             VARCHAR(255)
â”œâ”€â”€ phone             VARCHAR(50)
â”œâ”€â”€ phone_raw         VARCHAR(100)
â”œâ”€â”€ street            VARCHAR(255) NOT NULL                â† problÃ©m
â”œâ”€â”€ city              VARCHAR(100) NOT NULL                â† problÃ©m
â”œâ”€â”€ postal_code       VARCHAR(20) NOT NULL                 â† problÃ©m
â”œâ”€â”€ country           VARCHAR(10) DEFAULT 'CZ'
â”œâ”€â”€ lat               DOUBLE PRECISION
â”œâ”€â”€ lng               DOUBLE PRECISION
â”œâ”€â”€ geocode_status    VARCHAR(20)                          â† problÃ©m
â”œâ”€â”€ is_anonymized     BOOLEAN NOT NULL DEFAULT FALSE       â† novÃ© (soft delete)
â”œâ”€â”€ anonymized_at     TIMESTAMPTZ                          â† novÃ© (audit stopa)
â”œâ”€â”€ notes             TEXT
â”œâ”€â”€ created_at        TIMESTAMPTZ
â””â”€â”€ updated_at        TIMESTAMPTZ
```

**ProblÃ©my:**

| Sloupec | AktuÃ¡lnÃ­ typ | ProblÃ©m | DoporuÄenÃ­ |
|---------|-------------|---------|------------|
| `name` | `VARCHAR(255) NOT NULL` | ZÃ¡kaznÃ­k mÅ¯Å¾e mÃ­t zcela prÃ¡zdnou adresu i jmÃ©no (staÄÃ­ email/phone). `NOT NULL` brÃ¡nÃ­ importu. | ZmÄ›nit na `VARCHAR(255) NULL` |
| `street` | `VARCHAR(255) NOT NULL` | ZÃ¡kaznÃ­k mÅ¯Å¾e mÃ­t zcela prÃ¡zdnou adresu. | ZmÄ›nit na `VARCHAR(255) NULL` |
| `city` | `VARCHAR(100) NOT NULL` | ZÃ¡kaznÃ­k mÅ¯Å¾e mÃ­t zcela prÃ¡zdnou adresu. | ZmÄ›nit na `VARCHAR(100) NULL` |
| `postal_code` | `VARCHAR(20) NOT NULL` | ZÃ¡kaznÃ­k mÅ¯Å¾e mÃ­t zcela prÃ¡zdnou adresu. | ZmÄ›nit na `VARCHAR(20) NULL` |
| `geocode_status` | `VARCHAR(20)` | TÅ™Ã­hodnotovÃ½ stav (`pending`, `success`, `failed`) uloÅ¾enÃ½ jako volnÃ½ string. PÅ™estoÅ¾e to nenÃ­ boolean (mÃ¡ 3 stavy, ne 2), mÄ›l by to bÃ½t ENUM pro typovou bezpeÄnost. Geocode status se neimportuje, je vÃ½sledek nÃ¡slednÃ©ho geocodingu. | `geocode_status_enum ENUM('pending','success','failed') DEFAULT 'pending'` |
| `phone` | `VARCHAR(50)` | ZbyteÄnÄ› velkÃ½. E.164 = max 16 znakÅ¯. | `VARCHAR(20)` |
| `country` | `VARCHAR(10)` | ISO alpha-2 = 2 znaky. | `CHAR(2) DEFAULT 'CZ'` â€“ nenÃ­ kritickÃ© |

**PoznÃ¡mka k mazÃ¡nÃ­ zÃ¡kaznÃ­ka (aktuÃ¡lnÃ­ implementace):**

- `customers` se pÅ™i "smazÃ¡nÃ­" fyzicky nemaÅ¾ou.
- ZÃ¡znam je anonymizovÃ¡n (`is_anonymized = TRUE`, `anonymized_at = NOW()`), PII pole jsou vyÄiÅ¡tÄ›na.
- ÄŒtecÃ­ dotazy pro zÃ¡kaznÃ­ky filtrujÃ­ `is_anonymized = FALSE`, takÅ¾e anonymizovanÃ­ zÃ¡kaznÃ­ci nejsou vidÄ›t v UI.
- Vazby v dalÅ¡Ã­ch tabulkÃ¡ch zÅ¯stÃ¡vajÃ­ zachovanÃ© (FK integrita), navazujÃ­cÃ­ PII je anonymizovÃ¡na.
- API kontrakt: `sazinka.customer.delete` vracÃ­ `deleted: true` i kdyÅ¾ jde o soft anonymizaci, nikoliv hard delete.

**ProÄ `geocode_status` nemÅ¯Å¾e bÃ½t boolean:**

Hodnota `geocode_status` mÃ¡ 3 stavy:
- `pending` â€“ adresa uloÅ¾ena, geokÃ³dovÃ¡nÃ­ jeÅ¡tÄ› neprobÄ›hlo
- `success` â€“ geokÃ³dovÃ¡nÃ­ ÃºspÄ›Å¡nÃ©, lat/lng jsou vyplnÄ›ny
- `failed` â€“ geokÃ³dovÃ¡nÃ­ selhalo (adresa nenalezena, API chyba)

Boolean by nedokÃ¡zal rozliÅ¡it stav "jeÅ¡tÄ› nezpracovÃ¡no" od "zpracovÃ¡no neÃºspÄ›Å¡nÄ›". SprÃ¡vnÃ½ typ je **ENUM** (ne volnÃ½ VARCHAR). Hodnota se neimportuje, vznikÃ¡ z geocoding procesu po importu.

### 2.3 Tabulka `devices`

```
devices
â”œâ”€â”€ id                        UUID PK
â”œâ”€â”€ customer_id               UUID FK â†’ customers NOT NULL
â”œâ”€â”€ device_type               VARCHAR(50) NOT NULL
â”œâ”€â”€ manufacturer              VARCHAR(100)
â”œâ”€â”€ model                     VARCHAR(100)
â”œâ”€â”€ serial_number             VARCHAR(100)
â”œâ”€â”€ installation_date         DATE
â”œâ”€â”€ revision_interval_months  INTEGER DEFAULT 12
â”œâ”€â”€ notes                     TEXT
â””â”€â”€ created_at                TIMESTAMPTZ
```

**ProblÃ©my:**

| Sloupec | ProblÃ©m | DoporuÄenÃ­ |
|---------|---------|------------|
| ~~`device_name`~~ | **ChybÃ­!** `device_name` je klÃ­ÄovÃ½ identifikÃ¡tor pro rozliÅ¡enÃ­ zaÅ™Ã­zenÃ­ jednoho zÃ¡kaznÃ­ka. MusÃ­ bÃ½t povinnÃ½, pokud mÃ¡ zÃ¡kaznÃ­k vÃ­ce zaÅ™Ã­zenÃ­, bez ohledu na `serial_number`. ChybÄ›jÃ­cÃ­ hodnoty pÅ™i importu se majÃ­ nahradit generovanÃ½m nÃ¡zvem (napÅ™. â€ZaÅ™Ã­zenÃ­ 1â€œ) a vyvolat varovÃ¡nÃ­. | PÅ™idat `device_name VARCHAR(100)` + pravidlo generovÃ¡nÃ­ |
| `device_type` | `VARCHAR(50)` â€“ volnÃ½ string mÃ­sto ENUM. Riziko nekonzistentnÃ­ch hodnot. | `device_type_enum ENUM(...)` |
| `user_id` | **ChybÃ­!** ZaÅ™Ã­zenÃ­ nemÃ¡ pÅ™Ã­mÃ½ FK na uÅ¾ivatele, vazba je pouze pÅ™es `customer_id`. PÅ™i dotazech to vyÅ¾aduje vÅ¾dy JOIN pÅ™es customers. | ZvÃ¡Å¾it pÅ™idÃ¡nÃ­ `user_id UUID FK â†’ users` pro pÅ™Ã­mÃ© dotazy |
| `updated_at` | **ChybÃ­!** OstatnÃ­ tabulky majÃ­ `updated_at` s triggerem, devices ne. | PÅ™idat `updated_at TIMESTAMPTZ` s triggerem |
| UnikÃ¡tnÃ­ index | **ChybÃ­!** Å½Ã¡dnÃ½ unikÃ¡tnÃ­ index na `(customer_id, serial_number)` ani `(customer_id, device_type, device_name)`. Import duplikÃ¡tnÃ­ detekce spolÃ©hÃ¡ na aplikaÄnÃ­ logiku. | PÅ™idat UNIQUE indexy |

**KritickÃ½ problÃ©m â€“ `device_name`:** Import specifikace (PROJECT_IMPORT.MD, sekce 11.6 a 15.3) definuje hierarchii identifikace zaÅ™Ã­zenÃ­: `serial_number` â†’ `device_name` â†’ `device_type` (pokud jen 1 zaÅ™Ã­zenÃ­ typu). NavÃ­c `device_name` je povinnÃ½, pokud mÃ¡ zÃ¡kaznÃ­k vÃ­ce zaÅ™Ã­zenÃ­, i kdyÅ¾ je vyplnÄ›n `serial_number`. Ale:
- Sloupec `device_name` v databÃ¡zi **neexistuje**
- `resolve_device_ref()` hledÃ¡ **pouze** podle `serial_number`
- Pokud zaÅ™Ã­zenÃ­ nemÃ¡ sÃ©riovÃ© ÄÃ­slo (komÃ­ny, krby), `device_ref` v CSV (napÅ™. `"KomÃ­n na chalupÄ›"`) se nikdy nenajde

### 2.4 Tabulka `revisions`

```
revisions
â”œâ”€â”€ id                      UUID PK
â”œâ”€â”€ device_id               UUID FK â†’ devices NOT NULL
â”œâ”€â”€ customer_id             UUID FK â†’ customers NOT NULL
â”œâ”€â”€ user_id                 UUID FK â†’ users NOT NULL
â”œâ”€â”€ status                  VARCHAR(20) DEFAULT 'upcoming'
â”œâ”€â”€ due_date                DATE NOT NULL
â”œâ”€â”€ scheduled_date          DATE
â”œâ”€â”€ scheduled_time_start    TIME
â”œâ”€â”€ scheduled_time_end      TIME
â”œâ”€â”€ completed_at            TIMESTAMPTZ
â”œâ”€â”€ duration_minutes        INTEGER
â”œâ”€â”€ result                  VARCHAR(20)
â”œâ”€â”€ findings                TEXT
â”œâ”€â”€ snooze_until            DATE
â”œâ”€â”€ snooze_reason           VARCHAR(255)
â”œâ”€â”€ assigned_crew_id        UUID FK â†’ crews
â”œâ”€â”€ route_order             INTEGER
â”œâ”€â”€ created_at              TIMESTAMPTZ
â””â”€â”€ updated_at              TIMESTAMPTZ
```

**ProblÃ©my:**

| Sloupec | ProblÃ©m | DoporuÄenÃ­ |
|---------|---------|------------|
| `status` | `VARCHAR(20)` â€“ volnÃ½ string. V Rust kÃ³du existuje `RevisionStatus` enum, ale v DB je to string. Hodnoty `upcoming`, `due_soon`, `overdue`, `scheduled`, `confirmed`, `completed`, `cancelled` â€“ kde `due_soon` a `overdue` jsou **vypoÄÃ­tanÃ©** stavy, nemÄ›ly by se uklÃ¡dat. | ENUM se stavy: `upcoming`, `scheduled`, `confirmed`, `completed`, `cancelled` |
| `result` | `VARCHAR(20)` â€“ mÄ›l by bÃ½t ENUM: `passed`, `conditional`, `failed`. | ENUM |
| DuplicitnÃ­ index | **ChybÃ­!** Spec Å™Ã­kÃ¡: revize je duplicitnÃ­ pokud `device_id + due_date` je stejnÃ©. Å½Ã¡dnÃ½ UNIQUE index. | `UNIQUE(device_id, due_date)` |
| PÅ™Ã­Å¡tÃ­ termÃ­n | Po provedenÃ­ revize se mÃ¡ **okamÅ¾itÄ›** vypoÄÃ­tat a persistovat datum pÅ™Ã­Å¡tÃ­ revize. V aktuÃ¡lnÃ­m modelu nenÃ­ explicitnÃ­ pole. | PÅ™idat `next_due_date` na zaÅ™Ã­zenÃ­ nebo revizi (viz cÃ­lovÃ½ stav) |

**KritickÃ½ problÃ©m â€“ import ignoruje stav a vÃ½sledek:**

Funkce `create_revision()` v `revision.rs` **hardcoduje** `status = 'upcoming'` a nepÅ™ijÃ­mÃ¡ parametry `status`, `completed_at`, `duration_minutes`, `result`. To znamenÃ¡:

- CSV Å™Ã¡dek: `status=completed, result=passed, completed_at=2024-01-11T18:23:00, duration_minutes=60`
- V databÃ¡zi: `status='upcoming', completed_at=NULL, duration_minutes=NULL, result=NULL`

**CelÃ¡ historie dokonÄenÃ½ch revizÃ­ se pÅ™i importu ztrÃ¡cÃ­.**

### 2.5 Tabulka `visits`

```
visits
â”œâ”€â”€ id                    UUID PK
â”œâ”€â”€ user_id               UUID FK â†’ users NOT NULL
â”œâ”€â”€ customer_id           UUID FK â†’ customers NOT NULL
â”œâ”€â”€ revision_id           UUID FK â†’ revisions (nullable)
â”œâ”€â”€ scheduled_date        DATE NOT NULL
â”œâ”€â”€ scheduled_time_start  TIME
â”œâ”€â”€ scheduled_time_end    TIME
â”œâ”€â”€ status                VARCHAR(20) DEFAULT 'planned'
â”œâ”€â”€ visit_type            VARCHAR(30) DEFAULT 'revision'
â”œâ”€â”€ actual_arrival        TIMESTAMPTZ
â”œâ”€â”€ actual_departure      TIMESTAMPTZ
â”œâ”€â”€ result                VARCHAR(30)
â”œâ”€â”€ result_notes          TEXT
â”œâ”€â”€ requires_follow_up    BOOLEAN DEFAULT FALSE
â”œâ”€â”€ follow_up_reason      TEXT
â”œâ”€â”€ created_at            TIMESTAMPTZ
â””â”€â”€ updated_at            TIMESTAMPTZ
```

**ProblÃ©my:**

| Sloupec | ProblÃ©m | DoporuÄenÃ­ |
|---------|---------|------------|
| `status` | `VARCHAR(20)` â€“ mÄ›l by bÃ½t ENUM | ENUM |
| `visit_type` | `VARCHAR(30)` â€“ mÄ›l by bÃ½t ENUM | ENUM |
| `result` | `VARCHAR(30)` â€“ mÄ›l by bÃ½t ENUM | ENUM |
| `revision_id` | NÃ¡vÅ¡tÄ›va odkazuje na jednu revizi. Ale pÅ™i jednÃ© nÃ¡vÅ¡tÄ›vÄ› se mÅ¯Å¾e udÄ›lat vÃ­ce ÃºkonÅ¯ (revize kotle + oprava komÃ­nu). | Viz cÃ­lovÃ½ model â€“ vazba pÅ™es `visit_work_items` |
| `device_id` | **ChybÃ­!** NÃ¡vÅ¡tÄ›va nemÃ¡ pÅ™Ã­mou vazbu na zaÅ™Ã­zenÃ­. Jen nepÅ™Ã­mo pÅ™es `revision_id`. Co nÃ¡vÅ¡tÄ›vy typu `repair`, `installation`? | PÅ™idat `device_id` nebo vazebnÃ­ tabulku |

**KritickÃ½ problÃ©m â€“ import ignoruje vÄ›tÅ¡inu polÃ­:**

Import procesor (`import_processors.rs`) volÃ¡ `queries::visit::create_visit()`, kterÃ¡ hardcoduje `status='planned'` a `requires_follow_up=FALSE`. IgnorovanÃ© sloupce z CSV:
- `status` (napÅ™. `completed`, `rescheduled`)
- `result` (napÅ™. `successful`, `partial`, `failed`)
- `result_notes`
- `requires_follow_up`
- `follow_up_reason`

PÅ™itom existuje funkce `queries::import::create_visit_import()`, kterÃ¡ vÅ¡echna tato pole sprÃ¡vnÄ› pÅ™ijÃ­mÃ¡ â€“ ale import procesor ji **nepouÅ¾Ã­vÃ¡**.

### 2.6 Tabulka `communications`

```
communications
â”œâ”€â”€ id                UUID PK
â”œâ”€â”€ user_id           UUID FK â†’ users NOT NULL
â”œâ”€â”€ customer_id       UUID FK â†’ customers NOT NULL
â”œâ”€â”€ revision_id       UUID FK â†’ revisions (nullable)
â”œâ”€â”€ comm_type         VARCHAR(20) NOT NULL
â”œâ”€â”€ direction         VARCHAR(10) NOT NULL
â”œâ”€â”€ subject           VARCHAR(255)
â”œâ”€â”€ content           TEXT NOT NULL
â”œâ”€â”€ contact_name      VARCHAR(255)
â”œâ”€â”€ contact_phone     VARCHAR(50)
â”œâ”€â”€ email_status      VARCHAR(20)
â”œâ”€â”€ duration_minutes  INTEGER
â”œâ”€â”€ follow_up_date    DATE
â”œâ”€â”€ follow_up_completed BOOLEAN DEFAULT FALSE
â””â”€â”€ created_at        TIMESTAMPTZ
```

**ProblÃ©my:**

| Sloupec | ProblÃ©m |
|---------|---------|
| `comm_type` | `VARCHAR(20)` â€“ mÄ›l by bÃ½t ENUM |
| `direction` | `VARCHAR(10)` â€“ mÄ›l by bÃ½t ENUM |
| `email_status` | `VARCHAR(20)` â€“ mÄ›l by bÃ½t ENUM |
| `updated_at` | **ChybÃ­!** |

### 2.7 Tabulka `crews`

```
crews
â”œâ”€â”€ id                  UUID PK
â”œâ”€â”€ user_id             UUID FK â†’ users NOT NULL
â”œâ”€â”€ name                VARCHAR(100) NOT NULL
â”œâ”€â”€ home_depot_id       UUID FK â†’ depots (nullable)
â”œâ”€â”€ preferred_areas     TEXT[] DEFAULT '{}'
â”œâ”€â”€ working_hours_start TIME DEFAULT '08:00'
â”œâ”€â”€ working_hours_end   TIME DEFAULT '17:00'
â”œâ”€â”€ is_active           BOOLEAN DEFAULT TRUE
â”œâ”€â”€ created_at          TIMESTAMPTZ
â””â”€â”€ updated_at          TIMESTAMPTZ
```

**Bez zÃ¡sadnÃ­ch problÃ©mÅ¯.** Drobnosti:

| Sloupec | PoznÃ¡mka |
|---------|----------|
| `preferred_areas` | `TEXT[]` â€“ v poÅ™Ã¡dku pro PostgreSQL, ale ztÄ›Å¾uje portabilitu na jinÃ© DB. |

### 2.8 Tabulka `depots`

```
depots
â”œâ”€â”€ id          UUID PK
â”œâ”€â”€ user_id     UUID FK â†’ users NOT NULL
â”œâ”€â”€ name        VARCHAR(100) NOT NULL
â”œâ”€â”€ street      VARCHAR(255)
â”œâ”€â”€ city        VARCHAR(100)
â”œâ”€â”€ postal_code VARCHAR(20)
â”œâ”€â”€ country     VARCHAR(10) DEFAULT 'CZ'
â”œâ”€â”€ lat         DOUBLE PRECISION NOT NULL
â”œâ”€â”€ lng         DOUBLE PRECISION NOT NULL
â”œâ”€â”€ is_primary  BOOLEAN DEFAULT FALSE
â”œâ”€â”€ created_at  TIMESTAMPTZ
â””â”€â”€ updated_at  TIMESTAMPTZ
```

**Bez zÃ¡sadnÃ­ch problÃ©mÅ¯.** UnikÃ¡tnÃ­ index na `(user_id) WHERE is_primary = true` je sprÃ¡vnÄ›.

### 2.9 Tabulka `routes`

```
routes
â”œâ”€â”€ id                      UUID PK
â”œâ”€â”€ user_id                 UUID FK â†’ users NOT NULL
â”œâ”€â”€ date                    DATE NOT NULL
â”œâ”€â”€ status                  VARCHAR(20) DEFAULT 'draft'
â”œâ”€â”€ total_distance_km       DOUBLE PRECISION
â”œâ”€â”€ total_duration_minutes  INTEGER
â”œâ”€â”€ optimization_score      INTEGER
â”œâ”€â”€ created_at              TIMESTAMPTZ
â”œâ”€â”€ updated_at              TIMESTAMPTZ
â””â”€â”€ UNIQUE(user_id, date)
```

**ProblÃ©my:**

| Sloupec | ProblÃ©m |
|---------|---------|
| `status` | `VARCHAR(20)` â€“ mÄ›l by bÃ½t ENUM |
| `crew_id` | **ChybÃ­!** Trasa nenÃ­ pÅ™iÅ™azena posÃ¡dce. `UNIQUE(user_id, date)` brÃ¡nÃ­ mÃ­t dvÄ› trasy pro rÅ¯znÃ© posÃ¡dky ve stejnÃ½ den. | 

### 2.10 Tabulka `route_stops`

```
route_stops
â”œâ”€â”€ id                             UUID PK
â”œâ”€â”€ route_id                       UUID FK â†’ routes NOT NULL
â”œâ”€â”€ revision_id                    UUID FK â†’ revisions NOT NULL    â† problÃ©m
â”œâ”€â”€ stop_order                     INTEGER NOT NULL
â”œâ”€â”€ estimated_arrival              TIME
â”œâ”€â”€ estimated_departure            TIME
â”œâ”€â”€ distance_from_previous_km      DOUBLE PRECISION
â”œâ”€â”€ duration_from_previous_minutes INTEGER
â”œâ”€â”€ status                         VARCHAR(20) DEFAULT 'pending'
â”œâ”€â”€ actual_arrival                 TIMESTAMPTZ
â”œâ”€â”€ actual_departure               TIMESTAMPTZ
â””â”€â”€ UNIQUE(route_id, stop_order)
```

**ProblÃ©my:**

| Sloupec | ProblÃ©m |
|---------|---------|
| `revision_id` | ZastÃ¡vka je vÃ¡zÃ¡na na **revizi**, ne na **zÃ¡kaznÃ­ka** nebo **nÃ¡vÅ¡tÄ›vu**. To brÃ¡nÃ­ plÃ¡novÃ¡nÃ­ tras pro opravy, instalace atd. |
| `status` | `VARCHAR(20)` â€“ mÄ›l by bÃ½t ENUM |

---

## 3. ProblÃ©my aktuÃ¡lnÃ­ho stavu

### 3.1 SÃ©mantickÃ¡ redundance: `revisions` vs `visits`

AktuÃ¡lnÃ­ model mÃ¡ dvÄ› oddÄ›lenÃ© tabulky, kterÃ© popisujÃ­ tÃ©mÄ›Å™ totÃ©Å¾:

| Aspekt | `revisions` | `visits` |
|--------|-------------|----------|
| Co popisuje | Revize zaÅ™Ã­zenÃ­ (povinnost + provedenÃ­) | NÃ¡vÅ¡tÄ›va u zÃ¡kaznÃ­ka |
| Vazba na zaÅ™Ã­zenÃ­ | `device_id` (povinnÃ¡) | Å½Ã¡dnÃ¡ (nepÅ™Ã­mo pÅ™es `revision_id`) |
| PlÃ¡novÃ¡nÃ­ | `scheduled_date`, `time_start`, `time_end` | `scheduled_date`, `time_start`, `time_end` |
| VÃ½sledek | `result` (passed/conditional/failed) | `result` (successful/partial/failed/...) |
| Stav | `status` (upcoming/.../completed) | `status` (planned/.../completed) |
| Import | `revisions.csv` | `visits.csv` |

**DÅ¯sledek:** Pokud posÃ¡dka reviduje kotel zÃ¡kaznÃ­ka, musÃ­ to bÃ½t zapsÃ¡no **dvakrÃ¡t** â€“ jako revize v `revisions` a jako nÃ¡vÅ¡tÄ›va typu `revision` v `visits`. Neexistuje propojenÃ­ mezi nimi (kromÄ› volitelnÃ©ho `revision_id` ve `visits`).

### 3.2 ChybÄ›jÃ­cÃ­ koncept "nÃ¡vÅ¡tÄ›va jako fyzickÃ¡ cesta"

AktuÃ¡lnÃ­ model nerozliÅ¡uje:
- **Co se musÃ­ udÄ›lat** (revize kotle do 15.3.2026) = povinnost/zakÃ¡zka
- **Kdy a kam se jede** (15.3.2026 v 9:00 k zÃ¡kaznÃ­kovi NovÃ¡k) = nÃ¡vÅ¡tÄ›va
- **Co se tam udÄ›lalo** (revidoval kotel + opravil komÃ­n) = pracovnÃ­ Ãºkon

PÅ™Ã­klad ze Å¾ivota: PosÃ¡dka jede k zÃ¡kaznÃ­kovi, kterÃ½ mÃ¡ kotel a komÃ­n. PÅ™i jednÃ© nÃ¡vÅ¡tÄ›vÄ›:
1. Reviduje kotel (revize) â†’ vÃ½sledek: `passed`
2. Opravuje komÃ­n (oprava) â†’ vÃ½sledek: `partial`

V aktuÃ¡lnÃ­m modelu:
- V `revisions` â†’ 1 zÃ¡znam pro kotel
- V `visits` â†’ 2 zÃ¡znamy? 1 zÃ¡znam? Jak propojit s opravou komÃ­nu?

### 3.3 ChybÄ›jÃ­cÃ­ `device_name` v databÃ¡zi

Import specifikace (PROJECT_IMPORT.MD) definuje `device_name` jako lidsky ÄitelnÃ½ identifikÃ¡tor zaÅ™Ã­zenÃ­. DatabÃ¡ze tento sloupec nemÃ¡. `resolve_device_ref()` hledÃ¡ pouze podle `serial_number`, takÅ¾e reference typu `"KomÃ­n na chalupÄ›"` nebo `"OhÅ™Ã­vaÄ koupelna"` v CSV se nikdy nenajdou.

### 3.4 VolnÃ© stringy mÃ­sto ENUM

VÄ›tÅ¡ina "typovÃ½ch" sloupcÅ¯ je `VARCHAR(20/30)` mÃ­sto PostgreSQL ENUM. To umoÅ¾Åˆuje nekonzistentnÃ­ data (pÅ™eklepy, neznÃ¡mÃ© hodnoty). DotÄenÃ© sloupce:

- `customers.geocode_status`
- `devices.device_type`
- `revisions.status`, `revisions.result`
- `visits.status`, `visits.visit_type`, `visits.result`
- `communications.comm_type`, `communications.direction`, `communications.email_status`
- `routes.status`
- `route_stops.status`

### 3.5 NekonzistentnÃ­ NOT NULL omezenÃ

Tabulka `customers` mÃ¡ `name`, `street`, `city`, `postal_code` jako `NOT NULL`, ale import specifikace explicitnÄ› povoluje zÃ¡kaznÃ­ky s minimÃ¡lnÃ­mi daty (jen email, jen telefon). To znamenÃ¡, Å¾e import procesor musÃ­ buÄ:
- VklÃ¡dat placeholder hodnoty (to se dÄ›je â€“ `name` je prÃ¡zdnÃ½ string pokud chybÃ­)
- Nebo selhÃ¡vat pÅ™i vloÅ¾enÃ­ (poruÅ¡enÃ­ NOT NULL)

### 3.6 Trasy nemajÃ­ vazbu na posÃ¡dku

Tabulka `routes` mÃ¡ `UNIQUE(user_id, date)`, ale nemÃ¡ `crew_id`. To znamenÃ¡, Å¾e uÅ¾ivatel mÅ¯Å¾e mÃ­t **maximÃ¡lnÄ› jednu trasu** za den. Pokud mÃ¡ dvÄ› posÃ¡dky, nemÅ¯Å¾e pro nÄ› naplÃ¡novat dvÄ› trasy na stejnÃ½ den.

### 3.7 Route stops vÃ¡zanÃ© na revisions, ne na zÃ¡kaznÃ­ky

`route_stops.revision_id` je `NOT NULL FK â†’ revisions`. To brÃ¡nÃ­ plÃ¡novÃ¡nÃ­ tras pro nÃ¡vÅ¡tÄ›vy, kterÃ© nejsou revize (opravy, instalace, konzultace).

---

## 4. CÃ­lovÃ½ stav â€“ schÃ©ma databÃ¡ze

### 4.1 Principy nÃ¡vrhu

1. **JasnÃ© oddÄ›lenÃ­:** povinnost (co se musÃ­) â‰  nÃ¡vÅ¡tÄ›va (kam se jede) â‰  Ãºkon (co se tam dÄ›lalo)
2. **ENUM mÃ­sto VARCHAR:** pro typovÃ© sloupce
3. **Nullable kde dÃ¡vÃ¡ smysl:** Å¾Ã¡dnÃ© faleÅ¡nÃ© NOT NULL
4. **`device_name`** jako identifikÃ¡tor zaÅ™Ã­zenÃ­
5. **PosÃ¡dka na trase:** podpora vÃ­ce tras/posÃ¡dek za den

### 4.2 Beze zmÄ›ny

Tabulky `users`, `depots`, `crews` zÅ¯stÃ¡vajÃ­ **beze zmÄ›ny** (pouze drobnÃ© vylepÅ¡enÃ­ typÅ¯).

### 4.3 Tabulka `customers` (cÃ­lovÃ½ stav)

```sql
-- ZmÄ›ny oproti aktuÃ¡lnÃ­mu stavu:
-- 1. name, street, city, postal_code â†’ nullable
-- 2. geocode_status â†’ ENUM
-- 3. phone â†’ VARCHAR(20)

CREATE TYPE geocode_status AS ENUM ('pending', 'success', 'failed');

ALTER TABLE customers
    ALTER COLUMN name DROP NOT NULL,
    ALTER COLUMN street DROP NOT NULL,
    ALTER COLUMN city DROP NOT NULL,
    ALTER COLUMN postal_code DROP NOT NULL;

-- geocode_status: migrace z VARCHAR na ENUM
ALTER TABLE customers
    ALTER COLUMN geocode_status TYPE geocode_status
    USING geocode_status::geocode_status;
```

### 4.4 Tabulka `devices` (cÃ­lovÃ½ stav)

```sql
-- ZmÄ›ny:
-- 1. PÅ™idat device_name
-- 2. PÅ™idat user_id pro pÅ™Ã­mÃ© dotazy
-- 3. PÅ™idat updated_at
-- 4. PÅ™idat next_due_date (persistovanÃ½ vÃ½poÄet po revizi)
-- 5. device_type â†’ ENUM
-- 6. UnikÃ¡tnÃ­ indexy

CREATE TYPE device_type_enum AS ENUM (
    'gas_boiler', 'gas_water_heater', 'chimney',
    'fireplace', 'gas_stove', 'other'
);

ALTER TABLE devices
    ADD COLUMN device_name VARCHAR(100),
    ADD COLUMN user_id UUID REFERENCES users(id),
    ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN next_due_date DATE;

-- UnikÃ¡tnÃ­ index pro sÃ©riovÃ© ÄÃ­slo (v rÃ¡mci zÃ¡kaznÃ­ka)
CREATE UNIQUE INDEX idx_devices_serial
    ON devices(customer_id, serial_number)
    WHERE serial_number IS NOT NULL;

-- UnikÃ¡tnÃ­ index pro device_name + device_type (v rÃ¡mci zÃ¡kaznÃ­ka)
CREATE UNIQUE INDEX idx_devices_name_type
    ON devices(customer_id, device_type, device_name)
    WHERE device_name IS NOT NULL;
```

### 4.5 Tabulka `revisions` (reviznÃ­ povinnosti)

**KoncepÄnÃ­ zmÄ›na:** Tabulka `revisions` popisuje **povinnost** (prÃ¡vnÃ­ nutnost provÃ©st kontrolu), nikoliv fyzickou nÃ¡vÅ¡tÄ›vu. Je to "zakÃ¡zka" â€“ co se musÃ­ udÄ›lat.

```sql
-- CÃ­lovÃ¡ struktura (po migraci):

CREATE TYPE revision_status AS ENUM (
    'upcoming',     -- povinnost existuje, jeÅ¡tÄ› nenaplÃ¡novÃ¡na
    'scheduled',    -- termÃ­n domluven
    'confirmed',    -- zÃ¡kaznÃ­kem potvrzeno
    'completed',    -- splnÄ›no (proveden pracovnÃ­ Ãºkon)
    'cancelled'     -- zruÅ¡eno
);

CREATE TYPE revision_result AS ENUM (
    'passed',       -- v poÅ™Ã¡dku
    'conditional',  -- s vÃ½hradami
    'failed'        -- nevyhovÄ›lo
);

-- HlavnÃ­ zmÄ›ny oproti aktuÃ¡lnÃ­mu stavu:
-- 1. status, result â†’ ENUM
-- 2. PÅ™idÃ¡n fulfilled_by_work_item_id â†’ odkaz na konkrÃ©tnÃ­ Ãºkon, kterÃ½ revizi splnil
-- 3. UNIQUE(device_id, due_date) pro detekci duplicit

ALTER TABLE revisions
    ADD COLUMN fulfilled_by_work_item_id UUID;
    -- FK bude pÅ™idÃ¡na po vytvoÅ™enÃ­ tabulky visit_work_items

CREATE UNIQUE INDEX idx_revisions_device_due
    ON revisions(device_id, due_date);
```

**DÅ¯leÅ¾itÃ©:** `completed_at`, `duration_minutes` a `result` zÅ¯stÃ¡vajÃ­ na revizi jako denormalizovanÃ½ vÃ½sledek (kopÃ­rovÃ¡no z work_item pro rychlÃ© dotazy). Ale autoritativnÃ­ zdroj je `visit_work_items`. Po dokonÄenÃ­ revize se mÃ¡ **okamÅ¾itÄ›** pÅ™epoÄÃ­tat a persistovat `next_due_date` (na zaÅ™Ã­zenÃ­ nebo na revizi podle zvolenÃ©ho mÃ­sta).

### 4.6 Tabulka `visits` (fyzickÃ© nÃ¡vÅ¡tÄ›vy)

**KoncepÄnÃ­ zmÄ›na:** NÃ¡vÅ¡tÄ›va = fyzickÃ¡ cesta k zÃ¡kaznÃ­kovi. PÅ™i jednÃ© nÃ¡vÅ¡tÄ›vÄ› se mÅ¯Å¾e provÃ©st vÃ­ce ÃºkonÅ¯.

```sql
-- CÃ­lovÃ¡ struktura:

CREATE TYPE visit_status AS ENUM (
    'planned',       -- naplÃ¡novÃ¡no
    'in_progress',   -- probÃ­hÃ¡
    'completed',     -- dokonÄeno
    'cancelled',     -- zruÅ¡eno
    'rescheduled'    -- pÅ™eplÃ¡novÃ¡no
);

-- HlavnÃ­ zmÄ›na: typ prÃ¡ce se pÅ™esouvÃ¡ na work_item, nÃ¡vÅ¡tÄ›va je pouze "cesta k zÃ¡kaznÃ­kovi"

-- visits tabulka zÅ¯stÃ¡vÃ¡ podobnÃ¡, ale:
-- 1. visit_type je povaÅ¾ovÃ¡n za legacy (typ prÃ¡ce je na work_items)
-- 2. OdstranÄ›n revision_id (nahrazen vazbou pÅ™es work_items)
-- 3. result se vyhodnocuje z work_items
-- 4. PÅ™idÃ¡n crew_id (volitelnÃ½, v importu nepovinnÃ½)
-- 5. PÅ™idÃ¡n device_id (volitelnÃ½, pro zpÄ›tnou kompatibilitu s jednoduchÃ½mi pÅ™Ã­pady)

ALTER TABLE visits
    ADD COLUMN crew_id UUID REFERENCES crews(id),
    ADD COLUMN device_id UUID REFERENCES devices(id),
    DROP COLUMN revision_id;
    -- visit_type mÅ¯Å¾e doÄasnÄ› zÅ¯stat kvÅ¯li UI/API, ale cÃ­lovÄ› je autoritivnÃ­ work_item
```

### 4.7 NovÃ¡ tabulka `visit_work_items` (pracovnÃ­ Ãºkony)

```sql
CREATE TYPE work_type AS ENUM (
    'revision',       -- revize
    'repair',         -- oprava
    'installation',   -- instalace
    'consultation',   -- konzultace
    'follow_up'       -- nÃ¡slednÃ¡ kontrola
);

CREATE TYPE work_result AS ENUM (
    'successful',
    'partial',
    'failed',
    'customer_absent',
    'rescheduled'
);

CREATE TABLE visit_work_items (
    id                  UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    visit_id            UUID NOT NULL REFERENCES visits(id) ON DELETE CASCADE,
    device_id           UUID REFERENCES devices(id) ON DELETE SET NULL,
    revision_id         UUID REFERENCES revisions(id) ON DELETE SET NULL,
    crew_id             UUID REFERENCES crews(id) ON DELETE SET NULL,

    work_type           work_type NOT NULL,
    duration_minutes    INTEGER,
    result              work_result,
    result_notes        TEXT,
    findings            TEXT,

    requires_follow_up  BOOLEAN DEFAULT FALSE,
    follow_up_reason    TEXT,

    created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_work_items_visit ON visit_work_items(visit_id);
CREATE INDEX idx_work_items_device ON visit_work_items(device_id);
CREATE INDEX idx_work_items_revision ON visit_work_items(revision_id);
```

**PÅ™Ã­klad pouÅ¾itÃ­:**

PosÃ¡dka jede k zÃ¡kaznÃ­kovi `51647785` a provede dvÄ› vÄ›ci (s moÅ¾nostÃ­, Å¾e ÄÃ¡st prÃ¡ce udÄ›lÃ¡ jinÃ¡ posÃ¡dka):

```
visits (1 Å™Ã¡dek):
  id=V1, customer_id=C1, scheduled_date=2025-11-18, crew_id=CR1

visit_work_items (2 Å™Ã¡dky):
  id=WI1, visit_id=V1, device_id=D1(komÃ­n), revision_id=R3, work_type=revision,
      result=passed, findings="Bez zÃ¡vad"
  id=WI2, visit_id=V1, device_id=D2(CH-112373), work_type=repair, crew_id=CR2,
      result=partial, findings="Opraveno, ÄekÃ¡ se na dÃ­l", requires_follow_up=true
```

### 4.8 Tabulka `routes` (cÃ­lovÃ½ stav)

```sql
-- HlavnÃ­ zmÄ›na: pÅ™idÃ¡n crew_id, UNIQUE zmÄ›nÃ­ se na (user_id, date, crew_id)

ALTER TABLE routes
    ADD COLUMN crew_id UUID REFERENCES crews(id);

-- ZruÅ¡it starÃ½ UNIQUE index
ALTER TABLE routes DROP CONSTRAINT routes_user_id_date_key;

-- NovÃ½ UNIQUE index â€“ jedna trasa na posÃ¡dku za den
CREATE UNIQUE INDEX idx_routes_user_date_crew
    ON routes(user_id, date, crew_id);

-- PoznÃ¡mka: Trasa je plÃ¡novanÃ¡ pro jednu posÃ¡dku, ale work_items mohou bÃ½t provedeny
-- i jinou posÃ¡dkou (napÅ™. vÃ½pomoc). To se eviduje na work_item Ãºrovni.
```

### 4.9 Tabulka `route_stops` (cÃ­lovÃ½ stav)

```sql
-- HlavnÃ­ zmÄ›na: revision_id â†’ customer_id (zastÃ¡vka = zÃ¡kaznÃ­k, ne revize)
-- PÅ™idÃ¡n visit_id pro propojenÃ­ s nÃ¡vÅ¡tÄ›vou

ALTER TABLE route_stops
    ADD COLUMN customer_id UUID REFERENCES customers(id),
    ADD COLUMN visit_id UUID REFERENCES visits(id),
    ALTER COLUMN revision_id DROP NOT NULL;
    -- revision_id zÅ¯stÃ¡vÃ¡ jako nullable pro zpÄ›tnou kompatibilitu
```

---

## 5. Vazba na import (CSV)

### 5.1 AktuÃ¡lnÃ­ import â€“ co nefunguje

| CSV soubor | ProblÃ©m |
|------------|---------|
| `revisions.csv` | Import hardcoduje `status='upcoming'`, ignoruje `status`, `completed_at`, `duration_minutes`, `result`. **CelÃ¡ historie se ztrÃ¡cÃ­.** |
| `revisions.csv` | `resolve_device_ref()` hledÃ¡ jen podle `serial_number`. Reference typu `"KomÃ­n na chalupÄ›"` (device_name) nebo `"gas_boiler"` (device_type) se nenajdou. |
| `visits.csv` | Import volÃ¡ `create_visit()` mÃ­sto `create_visit_import()`. Hardcoduje `status='planned'`, ignoruje `status`, `result`, `result_notes`, `requires_follow_up`, `follow_up_reason`. |
| `visits.csv` | NeÅ™eÅ¡Ã­ propojenÃ­ `device_ref` â†’ `device_id`, protoÅ¾e tabulka `visits` sloupec `device_id` nemÃ¡. |

### 5.2 AktuÃ¡lnÃ­ import soubory vs cÃ­lovÃ½ model

#### ProblÃ©m redundance revisions.csv a visits.csv

AktuÃ¡lnÃ­ specifikace definuje **dva** soubory, kterÃ© popisujÃ­ pÅ™ekrÃ½vajÃ­cÃ­ se vÄ›ci:

| `revisions.csv` | `visits.csv` |
|------------------|-------------|
| Revize kotle (povinnost + provedenÃ­) | NÃ¡vÅ¡tÄ›va u zÃ¡kaznÃ­ka (typ: revision) |
| VÃ¡zÃ¡na na zaÅ™Ã­zenÃ­ (device_ref) | MÅ¯Å¾e ale nemusÃ­ bÃ½t vÃ¡zÃ¡na na zaÅ™Ã­zenÃ­ |
| Stav: upcoming/scheduled/.../completed | Stav: planned/.../completed |
| VÃ½sledek: passed/conditional/failed | VÃ½sledek: successful/partial/failed/... |

**ProblÃ©m:** Pokud zÃ¡kaznÃ­k mÃ¡ dvÄ› zaÅ™Ã­zenÃ­ a posÃ¡dka je navÅ¡tÃ­vila jednou, revizi jednoho zaÅ™Ã­zenÃ­ zapÃ­Å¡e do `revisions.csv`, ale opravu druhÃ©ho do `visits.csv` (jako `visit_type=repair`). Neexistuje propojenÃ­, Å¾e to byla jedna nÃ¡vÅ¡tÄ›va.

#### CÃ­lovÃ½ stav importu

V cÃ­lovÃ©m modelu bude import **breaking change** a nebudeme migrovat starÃ¡ data. PÅ™ed implementacÃ­ zmÄ›n bude databÃ¡ze smazÃ¡na. Import soubory musÃ­ reflektovat novÃ½ datovÃ½ model:

```
1. customers.csv       â†’ tabulka customers
2. devices.csv         â†’ tabulka devices (s device_name!)
3. revisions.csv       â†’ tabulka revisions (pouze povinnosti/zakÃ¡zky)
4. work_log.csv         â†’ tabulky visits + visit_work_items
5. communications.csv  â†’ tabulka communications
```

**`revisions.csv` (revidovanÃ½)** â€“ popisuje pouze **povinnosti** (zakÃ¡zky):

```csv
device_ref;customer_ref;due_date;status;result;completed_at;duration_minutes;findings
```

Stav `completed` s `result` a `completed_at` = povinnost byla splnÄ›na.

**`work_log.csv` (novÃ½, nahrazuje visits.csv)** â€“ popisuje **co se kdy kde dÄ›lalo**:

```csv
customer_ref;scheduled_date;scheduled_time_start;scheduled_time_end;device_ref;work_type;status;result;duration_minutes;result_notes;findings;requires_follow_up;follow_up_reason
```

Å˜Ã¡dky se **stejnÃ½m `customer_ref` + `scheduled_date`** se automaticky seskupÃ­ do jednÃ© nÃ¡vÅ¡tÄ›vy:

```csv
51647785;2025-11-18;10:00;11:30;KomÃ­n na chalupÄ›;revision;completed;successful;45;Bez zÃ¡vad;;false;
51647785;2025-11-18;10:00;11:30;CH-112373;repair;completed;partial;45;Opraveno;ÄŒekÃ¡ se na dÃ­l;true;Kontrola po opravÄ›
```

â†’ VytvoÅ™it 1 visit + 2 work_items.

### 5.3 PropojenÃ­ `revisions.csv` a `work_log.csv`

Pokud `work_type=revision` a `device_ref` je vyplnÄ›n, import se pokusÃ­ najÃ­t odpovÃ­dajÃ­cÃ­ reviznÃ­ povinnost (v `revisions`) a:
1. OznaÄit ji jako `completed`
2. Propojit pÅ™es `fulfilled_by_work_item_id`

Toto propojenÃ­ je **volitelnÃ©** â€“ work_log mÅ¯Å¾e existovat i bez odpovÃ­dajÃ­cÃ­ povinnosti v revisions.csv (ad-hoc prÃ¡ce).

### 5.4 `resolve_device_ref()` â€“ cÃ­lovÃ½ stav

```
1. Zkusit jako serial_number â†’ SELECT WHERE serial_number = $1
2. Zkusit jako device_name   â†’ SELECT WHERE device_name ILIKE $1    â† NOVÃ‰
3. Zkusit jako device_type   â†’ SELECT WHERE device_type = $1
                                AND count(same type for customer) = 1  â† NOVÃ‰
4. Nenalezeno â†’ chyba
```

---

## 6. MigraÄnÃ­ plÃ¡n

### FÃ¡ze 1: Opravy bez zmÄ›ny modelu (urgentnÃ­)

Tyto zmÄ›ny opravujÃ­ **aktuÃ¡lnÃ­ bugy** bez zmÄ›ny datovÃ©ho modelu:

1. **PÅ™idat `device_name`** do tabulky `devices` + pravidlo generovÃ¡nÃ­ nÃ¡zvu s varovÃ¡nÃ­m pÅ™i importu
2. **RozÅ¡Ã­Å™it `CreateRevisionRequest`** o `status`, `completed_at`, `duration_minutes`, `result`
3. **Opravit `create_revision()`** â€“ neardcodovat `status='upcoming'`
4. **Opravit import procesor pro visits** â€“ volat `create_visit_import()` mÃ­sto `create_visit()`
5. **RozÅ¡Ã­Å™it `resolve_device_ref()`** â€“ hledat i podle `device_name` a `device_type`
6. **ZmÄ›nit NOT NULL** na customers â€“ `name`, `street`, `city`, `postal_code`

### FÃ¡ze 2: VylepÅ¡enÃ­ typÅ¯

1. **PÅ™idat PostgreSQL ENUM** pro typovÃ© sloupce
2. **Migrace dat** z VARCHAR na ENUM (s fallback pro neznÃ¡mÃ© hodnoty)
3. **PÅ™idat chybÄ›jÃ­cÃ­ `updated_at`** na `devices` a `communications`
4. **PÅ™idat unikÃ¡tnÃ­ indexy** na `devices` a `revisions`

### FÃ¡ze 3: NovÃ½ datovÃ½ model (breaking change)

1. **PÅ™idat `crew_id` na `routes`**, zmÄ›nit UNIQUE index
2. **VytvoÅ™it tabulku `visit_work_items`**
3. **Refaktorovat `route_stops`** â€“ `customer_id` mÃ­sto `revision_id`
4. **VytvoÅ™it novÃ½ import formÃ¡t** (`work_log.csv`)
5. **Bez migrace dat** (DB se pÅ™ed zmÄ›nou smaÅ¾e)
6. **Aktualizovat PROJECT_IMPORT.MD**

### Priorita

| FÃ¡ze | Priorita | DÅ¯vod |
|------|----------|-------|
| 1 | **KritickÃ¡** | AktuÃ¡lnÃ­ import **ztrÃ¡cÃ­ data** (status, result). |
| 2 | StÅ™ednÃ­ | ZlepÅ¡uje integritu, ale nerozbÃ­jÃ­ funkÄnost. |
| 3 | NÃ­zkÃ¡ (design-first) | VyÅ¾aduje znaÄnÃ½ refaktoring frontendu i backendu. Nejprve navrhnout, pak implementovat. |

---

## 8. Database Indexes

DatabÃ¡ze mÃ¡ **~40 indexÅ¯** pro optimalizaci dotazÅ¯. VÅ¡echny foreign keys jsou indexovanÃ©, plus sloÅ¾enÃ© indexy pro ÄastÃ© multi-column queries.

### 8.1 Customers (zÃ¡kaznÃ­ci)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_customers_user` | Regular | `user_id` | FK index |
| `idx_customers_geocode` | Composite | `(user_id, geocode_status)` | Pro filtrovÃ¡nÃ­ geocode stavu |
| `idx_customers_user_anonymized` | Composite | `(user_id, is_anonymized)` | Pro GDPR queries |

### 8.2 Users (uÅ¾ivatelÃ©)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_users_role` | Regular | `role` | Pro RBAC |
| `idx_users_owner` | Regular | `owner_id` | FK index |
| `idx_users_default_crew_id` | Regular | `default_crew_id` | FK index |
| `idx_users_default_depot_id` | Regular | `default_depot_id` | FK index |

### 8.3 Depots (sklady)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_depots_primary` | **UNIQUE** | `(user_id, is_primary)` WHERE `is_primary = TRUE` | Pouze jeden primÃ¡rnÃ­ depot na uÅ¾ivatele |

### 8.4 Crews (Äety)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_crews_user` | Regular | `user_id` | FK index |

### 8.5 Devices (zaÅ™Ã­zenÃ­)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_devices_customer` | Regular | `customer_id` | FK index |
| `idx_devices_user` | Regular | `user_id` | FK index |
| `idx_devices_serial` | **UNIQUE** | `(user_id, serial_number)` WHERE `serial_number IS NOT NULL` | Partial index |
| `idx_devices_name_type` | **UNIQUE** | `(customer_id, name, device_type)` | Business constraint |

### 8.6 Revisions (revize)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_revisions_device` | Regular | `device_id` | FK index |
| `idx_revisions_customer` | Regular | `customer_id` | FK index |
| `idx_revisions_user` | Regular | `user_id` | FK index |
| `idx_revisions_status` | Composite | `(user_id, status)` | Pro filtrovÃ¡nÃ­ podle stavu |
| `idx_revisions_due` | Composite | `(user_id, due_date)` | Pro due date queries |
| `idx_revisions_user_scheduled_date` | Composite | `(user_id, scheduled_date)` WHERE `scheduled_date IS NOT NULL` | Partial index pro plÃ¡novanÃ© revize |
| `idx_revisions_completed_at` | Regular | `completed_at` WHERE `completed_at IS NOT NULL` | Partial index pro dokonÄenÃ© |
| `idx_revisions_device_due` | **UNIQUE** | `(device_id, due_date)` | Jedna revize na zaÅ™Ã­zenÃ­ na datum |

### 8.7 Visits (nÃ¡vÅ¡tÄ›vy)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_visits_user` | Regular | `user_id` | FK index |
| `idx_visits_customer` | Regular | `customer_id` | FK index |
| `idx_visits_date` | Composite | `(user_id, scheduled_date)` | Pro kalendÃ¡Å™ queries |
| `idx_visits_crew` | Regular | `crew_id` WHERE `crew_id IS NOT NULL` | Partial index |

### 8.8 Visit Work Items (pracovnÃ­ poloÅ¾ky nÃ¡vÅ¡tÄ›v)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_work_items_visit` | Regular | `visit_id` | FK index |
| `idx_work_items_device` | Regular | `device_id` WHERE `device_id IS NOT NULL` | Partial index |
| `idx_work_items_revision` | Regular | `revision_id` WHERE `revision_id IS NOT NULL` | Partial index |

### 8.9 Communications (komunikace)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_communications_customer` | Regular | `customer_id` | FK index |
| `idx_communications_user` | Regular | `user_id` | FK index |

### 8.10 Routes (trasy)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_routes_depot` | Regular | `depot_id` | FK index |
| `idx_routes_user_date_crew` | **UNIQUE** | `(user_id, route_date, crew_id)` | Jedna trasa na Äetu na den |

### 8.11 Route Stops (zastÃ¡vky tras)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_route_stops_route` | Regular | `route_id` | FK index |
| `idx_route_stops_type` | Regular | `stop_type` | Pro filtrovÃ¡nÃ­ typu zastÃ¡vky (break/customer) |
| `idx_route_stops_revision_id` | Regular | `revision_id` | FK index |

### 8.12 RBAC (Role-Based Access Control)

| Index | Typ | Sloupce | PoznÃ¡mka |
|-------|-----|---------|----------|
| `idx_roles_owner` | Regular | `owner_id` | FK index |
| `idx_role_permissions_role` | Regular | `role_id` | FK index |
| `idx_user_roles_user` | Regular | `user_id` | FK index |
| `idx_user_roles_role` | Regular | `role_id` | FK index |

### 8.13 Index Coverage Summary

âœ… **DobÅ™e pokrytÃ© oblasti:**
- VÅ¡echny foreign keys majÃ­ indexy
- ÄŒastÃ© filtry (`user_id`, `status`, `scheduled_date`)
- SloÅ¾enÃ© indexy pro multi-column queries
- Partial indexy (WHERE podmÃ­nky) pro Ãºsporu mÃ­sta
- UNIQUE indexy pro business constraints

ğŸ“Š **Statistiky:**
- **Celkem indexÅ¯**: ~40
- **UNIQUE indexÅ¯**: 6
- **Partial indexÅ¯**: 5 (WHERE podmÃ­nky)
- **Composite indexÅ¯**: 10+

ğŸ’¡ **PoznÃ¡mka**: Marketing site (D1 databÃ¡ze v Cloudflare) zatÃ­m indexy nemÃ¡ - obsahuje jen 2 jednoduchÃ© tabulky (`contacts`, `newsletter_subscribers`) bez high-traffic queries.
