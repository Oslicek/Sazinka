# Internationalization (i18n) Analysis

> Status: **Complete**
> Created: 2026-02-10

## Overview

This document captures all findings related to making Sazinka a multi-language, multi-culture application. The app is currently 100% Czech ‚Äî all UI text, backend messages, date/number formatting, validation messages, email templates, and even CSV import aliases are hardcoded in Czech.

**Estimated scope:** ~90 frontend files in `apps/web`, ~15 backend files, ~500+ string keys to externalize. **Out of scope:** `apps/site` (marketing/landing) ‚Äî separate i18n.

---

## Current State

- **No i18n library** installed in `apps/web`
- **No locale setting** in user profile, stores, or settings
- **No translation files** for the web app (only `apps/site/` has `cs.json`, `en.json`, `sk.json`)
- **`index.html`** has `<html lang="cs">` hardcoded
- **`<title>`** is hardcoded as `"Ariadline - CRM pro ≈ôemesln√≠ky"`
- **Czech-specific fields** in data model: `ico` (IƒåO), `dic` (DIƒå) ‚Äî these may need labels, not removal
- **Phone normalization** hardcodes `+420` prefix

---

## 1. Hardcoded UI Strings (Frontend)

### 1.1 Pages (~17 files, ~300 strings)

| File | Category | Est. Strings | Samples |
|------|----------|:---:|---------|
| `PlanningInbox.tsx` | Labels, tooltips, buttons, filters, errors | 50+ | "Nov√° revize", "Ne≈ôe≈°it", "V trase", "Smazat trasu", "Naƒç√≠t√°m p≈ôehled dne..." |
| `Settings.tsx` | Tabs, placeholders, errors, CRUD messages | 60+ | "Moje nastaven√≠", "Pracovn√≠ doba", "Opravdu chcete smazat?", "Ukl√°d√°m..." |
| `Calendar.tsx` | Month names, status labels, aria-labels | 25+ | `MONTH_NAMES` (Leden‚ÄìProsinec), "P≈ôedchoz√≠ obdob√≠", "Hledat z√°kazn√≠ka" |
| `Customers.tsx` | Filters, errors, empty states | 15+ | "Hledat z√°kazn√≠ky...", "≈Ω√°dn√≠ z√°kazn√≠ci neodpov√≠daj√≠", "Naƒç√≠st dal≈°√≠" |
| `CustomerSummary.tsx` | Stats labels | 20 | "Z√°kazn√≠k≈Ø celkem", "Za≈ô√≠zen√≠ celkem", "Nelze lokalizovat" |
| `Dashboard.tsx` | Status labels, stats | 12 | "Napl√°nov√°no", "Po term√≠nu", "z√°kazn√≠k≈Ø k obvol√°n√≠" |
| `Login.tsx` | Labels, placeholders, errors | 5 | "P≈ôihl√°≈°en√≠ do syst√©mu", "Heslo", "vas@email.cz" |
| `Register.tsx` | Placeholders | 8 | "Jan Nov√°k", "Minim√°lnƒõ 8 znak≈Ø", "Revize s.r.o." |
| `Jobs.tsx` | Status, relative time | 10 | "pr√°vƒõ teƒè", "p≈ôed Xm", "Zru≈°it √∫lohu" |
| `CallQueue.tsx` | Labels, buttons | 15 | "Telefon nen√≠ k dispozici", "üìÖ Napl√°novat" |
| `Routes.tsx` | Errors, tooltips | 5 | "Zobrazit v pl√°nu", "Smazat trasu" |
| `WorkLog.tsx` | Placeholders, errors | 12 | "Kr√°tk√© shrnut√≠ proveden√© pr√°ce" |
| `VisitDetail.tsx` | Placeholders, errors | 15 | "Pozn√°mky k n√°v≈°tƒõvƒõ...", "Dokonƒçit" |
| `RevisionDetail.tsx` | Errors, buttons | 12 | "Voliteln√Ω d≈Øvod odlo≈æen√≠...", "Potvrdit" |
| `Admin.tsx` | Titles, actions | 15 | "Spustit geok√≥dov√°n√≠...", "Restartovat slu≈æbu" |
| `About.tsx` | Entire page content | 12 | All Czech |
| `planningInboxFilters.ts` | Preset/filter labels | 20 | "V≈°e", "Akutn√≠", "Do 7 dn≈Ø", "Chyb√≠ telefon" |

### 1.2 Components (~52 files, ~200 strings)

**Planner (18 components):**
| File | Samples |
|------|---------|
| `CandidateDetail.tsx` | "Term√≠n: Ano/Ne", "V trase:", "Odlo≈æit o den/t√Ωden/mƒõs√≠c", "Zobrazit detail z√°kazn√≠ka ‚Üí" |
| `CandidateRow.tsx` | "M√° term√≠n", "V trase", "Chyb√≠ telefon", "P≈ôidan√° vzd√°lenost do trasy" |
| `RouteDetailTimeline.tsx` | "Potvrzeno", "Nepotvrzeno", "Odstranit pauzu", "Odebrat zast√°vku" |
| `PlanningTimeline.tsx` | "P≈ô√≠jezd X min pozdƒõ ‚Äî nutn√© domluvit nov√Ω ƒças", "Ukl√°d√°m..." |
| `ProblemsSegment.tsx` | "Chyb√≠ telefon", "Nelze geolokalizovat", "Doplnit telefon" |
| `RouteListPanel.tsx` | "zast.", "min", "km", "Naƒç√≠t√°m cesty..." |
| `CapacityMetrics.tsx` | "Celkov√° vzd√°lenost trasy", "km", "min" |
| `DraftModeBar.tsx` | "Nepoda≈ôilo se ulo≈æit", "Ukl√°d√°m..." |
| `SortableStopItem.tsx` | "Navigovat", "Zavolat", "Hotovo", "Zamknout" |
| `SlotSuggestions.tsx` | "Nelze vlo≈æit - ƒçasov√Ω konflikt" |
| `VirtualizedInboxList.tsx` | "≈Ω√°dn√≠ kandid√°ti", "Naƒç√≠st dal≈°√≠" |

**Customers (12 components):**
| File | Samples |
|------|---------|
| `CustomerForm.tsx` | 18+ labels and placeholders for all form fields |
| `AddCustomerForm.tsx` | 9+ labels, "Geok√≥dov√°n√≠ probƒõhne po ulo≈æen√≠ z√°kazn√≠ka" |
| `CustomerHeader.tsx` | "‚ûï Do pl√°nu", "Smazat z√°kazn√≠ka (anonymizace)" |
| `ImportCustomersModal.tsx` | "CSV soubor mus√≠ obsahovat...", "X z√°kazn√≠k≈Ø" |
| `DeleteConfirmDialog.tsx` | "Smazat z√°kazn√≠ka?", "Maz√°n√≠..." |

**Calendar (2 components):**
| File | Samples |
|------|---------|
| `CalendarGrid.tsx` | `WEEKDAY_NAMES = ['Po', '√öt', 'St', 'ƒåt', 'P√°', 'So', 'Ne']` |
| `DayCell.tsx` | "Napl√°nov√°no", "Po term√≠nu", "Prob√≠h√°" |

**Import (2 components):**
| File | Samples |
|------|---------|
| `ImportModal.tsx` | Entity labels (z√°kazn√≠k≈Ø, za≈ô√≠zen√≠, reviz√≠, komunikac√≠, n√°v≈°tƒõv) |
| `ImportReportDialog.tsx` | Issue code labels, duration format, "Dokonƒçeno s chybami" |

**Revisions (5), Devices (2), Settings (1), Common (2), Shared (2), Timeline (2), Worklog (1)** ‚Äî all contain Czech strings.

### 1.3 Services (~12 files)

| File | Strings |
|------|---------|
| `customerService.ts` | "Nepoda≈ôilo se ulo≈æit z√°kazn√≠ka" |
| `calendarService.ts` | "Z√°kazn√≠k", "Za≈ô√≠zen√≠" (fallbacks) |
| `exportService.ts` | 16+ CSV column labels (Jm√©no, Ulice, Mƒõsto, PSƒå, etc.) |
| `visitService.ts` | Status/type/result labels (Napl√°nov√°no, Prob√≠h√°, Revize, etc.) |
| `communicationService.ts` | Type labels (Odeslan√Ω e-mail, Telefon√°t, Pozn√°mka) |
| `workItemService.ts` | Work type/result labels |
| `import/importService.ts` | 10+ validation messages |
| `import/entityParsers.ts` | 20+ parsing errors |
| `insertionService.ts` | "+Xmin / +Ykm" format |

### 1.4 Stores (3 files)

| File | Strings |
|------|---------|
| `authStore.ts` | "P≈ô√≠li≈° mnoho pokus≈Ø", "Nespr√°vn√Ω email nebo heslo", "Chyba p≈ôi p≈ôihl√°≈°en√≠" |
| `activeJobsStore.ts` | Job type names, progress text (Import z√°kazn√≠k≈Ø, Geok√≥dov√°n√≠, Parsov√°n√≠ CSV) |
| `natsStore.ts` | "Nen√≠ p≈ôipojen√≠ k serveru", "Po≈æadavek vypr≈°el" |

### 1.5 Hooks (1 file)

| File | Strings |
|------|---------|
| `useKeyboardShortcuts.ts` | 10+ shortcut descriptions: "Zav≈ô√≠t", "Hledat", "Domluvit term√≠n", "Odlo≈æit" |

### 1.6 Utils (2 files)

| File | Strings |
|------|---------|
| `overdueUtils.ts` | Czech plurals: "1 rok", "2 roky", "5 let", "1 mƒõs√≠c", "2 mƒõs√≠ce", "5 mƒõs√≠c≈Ø", "1 den" |
| `customerValidation.ts` | "Jm√©no je povinn√©", "PSƒå mus√≠ m√≠t 5 ƒç√≠slic", "Mƒõsto je povinn√©" |

### 1.7 Types (1 file)

| File | Strings |
|------|---------|
| `jobStatus.ts` | Job type names: Geok√≥dov√°n√≠, Pl√°nov√°n√≠ trasy, Import dat, Export dat, etc. |

---

## 2. Shared Types / Enums (`packages/shared-types/`)

All label records are Czech-only:

| File | Record | Sample values |
|------|--------|---------------|
| `device.ts` | `DEVICE_TYPE_LABELS` | Plynov√Ω kotel, Kom√≠n, Krb, Plynov√Ω spor√°k |
| `workItem.ts` | `WORK_TYPE_LABELS` | Revize, Oprava, Instalace, Konzultace |
| `workItem.ts` | `WORK_RESULT_LABELS` | √öspƒõ≈°n√°, ƒå√°steƒçn√°, Ne√∫spƒõ≈°n√°, Nep≈ô√≠tomen |
| `route.ts` | `ROUTE_STATUS_LABELS` | Koncept, Optimalizov√°no, Potvrzeno |
| `revision.ts` | `REVISION_STATUS_LABELS` | Pl√°novan√°, Brzy, Po term√≠nu, Napl√°nov√°no |
| `revision.ts` | `REVISION_RESULT_LABELS` | V po≈ô√°dku, Nevyhovƒõlo, S v√Ωhradami |
| `auth.ts` | `PAGE_PERMISSIONS` | Kalendar, Inbox, Plan, Zaznam, Zakaznici |
| `auth.ts` | `SETTINGS_PERMISSIONS` | Moje nastaveni, Pracovni doba, etc. |

**Import aliases (Czech input forms for CSV parsing):**
- `DEVICE_TYPE_ALIASES` ‚Äî plynov√Ω kotel, oh≈ô√≠vaƒç, kom√≠n, krb, spor√°k
- `REVISION_STATUS_ALIASES` ‚Äî nadch√°zej√≠c√≠, pl√°novan√°, dokonƒçeno
- `COMMUNICATION_TYPE_ALIASES` ‚Äî hovor, email, pozn√°mka
- `VISIT_STATUS_ALIASES`, `WORK_TYPE_ALIASES`, `WORK_RESULT_ALIASES`, etc.

These aliases should remain as Czech inputs but additional locale aliases should be supported.

---

## 3. Date/Time Formatting

### 3.1 Frontend ‚Äî `toLocaleDateString('cs-CZ')` (30+ occurrences)

Used across ~25 files:

| Files (sample) | Usage |
|----------------|-------|
| `CandidateDetail.tsx`, `PlanningInbox.tsx` | `toLocaleDateString('cs-CZ', { day, month, year })` |
| `CustomerSummary.tsx`, `ImportCustomersModal.tsx` | `toLocaleString('cs-CZ')` for numbers |
| `Customers.tsx`, `Jobs.tsx`, `CustomerTable.tsx` | `toLocaleDateString('cs-CZ')` |
| `DraftModeBar.tsx` | `toLocaleTimeString('cs-CZ')` |
| `Calendar.tsx` | `toLocaleDateString('cs-CZ', { month: 'long' })` |
| `importService.ts` | Date/time formatting in reports |

### 3.2 Frontend ‚Äî Hardcoded Czech date patterns

| File | Pattern |
|------|---------|
| `CalendarGrid.tsx` | `WEEKDAY_NAMES = ['Po', '√öt', 'St', 'ƒåt', 'P√°', 'So', 'Ne']` |
| `Calendar.tsx` | `MONTH_NAMES` (Leden‚ÄìProsinec) |
| `RouteListPanel.tsx` | `formatDate()` ‚Äî `['Ne', 'Po', '√öt', 'St', 'ƒåt', 'P√°', 'So']` |

### 3.3 Backend ‚Äî Date parsing/formatting

| File | Format | Notes |
|------|--------|-------|
| `import_processors.rs` | `%d.%m.%Y` | Czech DD.MM.YYYY for CSV parsing |
| `route.rs`, `jobs.rs`, `slots.rs` | `%H:%M` | Time display in warnings |
| `export_processor.rs` | `%Y-%m-%d`, `%H:%M` | Export formatting |
| `types/settings.rs` | `%H:%M` | Time serialization |

---

## 4. Number Formatting

### 4.1 Units in UI (km, min, %, h, s)

| File | Pattern |
|------|---------|
| `CapacityMetrics.tsx` | "X km", "Xmin", "Xh", "XhXX" |
| `RouteListPanel.tsx` | "X min", "Xh", "XhXX" |
| `RouteDetailTimeline.tsx` | "Xh XXmin", "X km", "X min" |
| `CandidateRow.tsx` | `formatDelta` with "km", "min" suffixes |
| `CandidateDetail.tsx` | "X min" |
| `ImportReportDialog.tsx` | "X s", "X min X s" |
| `Jobs.tsx` | "Xs", "Xm Xs", "p≈ôed Xm", "p≈ôed Xh" |
| `breakUtils.ts` | "X km", "min", "minut" |
| `insertionService.ts` | "+Xmin / +Ykm" |
| `Dashboard.tsx` | "X%" |
| `Settings.tsx` | "Rezerva X %" |

### 4.2 Number locale

- `toLocaleString('cs-CZ')` used for thousand separators in ~5 places
- Decimal separator: Czech uses comma (1 234,5 km) vs English dot (1,234.5 km)

---

## 5. Backend Messages (Rust)

### 5.1 User-facing NATS responses (~80+ strings)

| Area | Files | Samples |
|------|-------|---------|
| **Import** | `import_processors.rs`, `import.rs` | "Chyba p≈ôi parsov√°n√≠ CSV", "CSV soubor neobsahuje ≈æ√°dn√© z√°znamy", "X/Y √∫spƒõ≈°nƒõ importov√°no" |
| **Route planning** | `jobs.rs` | "Naƒç√≠t√°n√≠ z√°kazn√≠k≈Ø...", "Optimalizace trasy...", "X zast√°vek, Y km" |
| **Route warnings** | `vrp/pragmatic.rs`, `vrp/mod.rs` | "p≈ô√≠jezd v X je po konci okna Y", "Optimaliz√°tor selhal" |
| **Slots** | `slots.rs`, `slot_suggester.rs` | "Slot je mimo pracovn√≠ dobu", "Slot se p≈ôekr√Ωv√° s n√°v≈°tƒõvou X" |
| **Insertion** | `insertion.rs` | "ƒåasov√Ω konflikt s okoln√≠mi zast√°vkami", "Mimo pracovn√≠ dobu" |
| **Export** | `export_processor.rs` | "Naƒç√≠t√°n√≠ dat...", "Generov√°n√≠ CSV...", "Balen√≠ ZIP..." |

### 5.2 Email templates (Czech)

| File | Content |
|------|---------|
| `types/settings.rs` | `DEFAULT_REMINDER_EMAIL_TEMPLATE` ‚Äî full Czech email body |
| `types/settings.rs` | `DEFAULT_CONFIRMATION_EMAIL_TEMPLATE` ‚Äî full Czech email body |
| `types/settings.rs` | Default subjects: "P≈ôipom√≠nka term√≠nu - {{customerName}}", "Potvrzen√≠ term√≠nu - {{customerName}}" |

### 5.3 Mixed Czech/English

Some backend messages are in English: "Database reset successfully", "Authentication required", "Job cancellation requested". These should be unified.

### 5.4 Czech-specific conventions

- Phone normalization: `+420` prefix in `import_processors.rs`
- Geocoding: `"Czech Republic"` appended to addresses
- Default user address: `V√°clavsk√© n√°mƒõst√≠ 1, Praha, 11000`

---

## 6. Pluralization

Czech has complex plural forms (1 / 2-4 / 5+):

| Location | Pattern |
|----------|---------|
| `overdueUtils.ts` | "1 rok" / "2 roky" / "5 let", "1 mƒõs√≠c" / "2 mƒõs√≠ce" / "5 mƒõs√≠c≈Ø" |
| `PlanningInbox.tsx` | "1 n√°v≈°tƒõva" / "2 n√°v≈°tƒõvy" / "5 n√°v≈°tƒõv" |
| `Jobs.tsx` | "p≈ôed 1m" / "p≈ôed Xm" |
| Various | "X dn√≠/dny/den", "v√Ωsledk≈Ø" |

An i18n library with ICU MessageFormat or similar pluralization support is required.

---

## 7. Scope Summary

### Files requiring i18n changes

| Layer | Files | Strings |
|-------|:-----:|:-------:|
| Pages | 17 | ~300 |
| Components | 52 | ~200 |
| Services | 12 | ~60 |
| Stores | 3 | ~15 |
| Hooks | 1 | ~10 |
| Utils | 2 | ~20 |
| Types/shared | 8 | ~50 |
| **Frontend subtotal** | **~95** | **~655** |
| Backend handlers | 6 | ~80 |
| Backend services | 5 | ~30 |
| Backend types | 2 | ~10 |
| **Backend subtotal** | **~13** | **~120** |
| **TOTAL** | **~108** | **~775** |

### What needs to happen

1. ~~**Choose i18n library**~~ ‚Äî **Decided:** `i18next` + `react-i18next` (see Part 2)
2. ~~**Add locale setting**~~ ‚Äî **Decided:** stored in DB, `VARCHAR(10)`, default `'en'` (see Part 2)
3. ~~**Create translation file structure**~~ ‚Äî **Decided:** namespaced JSON in `public/locales/{lng}/{ns}.json` (see Part 2)
4. **Extract all ~655 frontend strings** into translation keys ‚Äî Phase 1-7
5. ~~**Create backend i18n layer**~~ ‚Äî **Decided:** backend sends `{ key, params }` (colon convention); frontend resolves via `resolveBackendMessage()` (see Part 2)
6. **Replace `'cs-CZ'` hardcoded locale** with `i18n.language` via centralized `formatters.ts` ‚Äî Phase 1-7
7. **Replace hardcoded date/weekday/month names** with native `Intl` via `formatters.ts` ‚Äî Phase 1-7
8. ~~**Handle pluralization**~~ ‚Äî **Decided:** CLDR rules via i18next (`one`, `few`, `other`) (see Part 2)
9. **Make email templates locale-aware** ‚Äî per-locale defaults for new accounts; never modify existing ‚Äî Phase 6
10. **Support locale-specific import aliases** ‚Äî tolerant mode, all locales accepted ‚Äî Phase 5
11. **Update `index.html`** ‚Äî dynamic `lang` attribute via `document.documentElement.lang` ‚Äî Phase 0
12. ~~**Consider RTL**~~ ‚Äî **Excluded** (no Arabic/Hebrew market planned)

### Rollout priority

> See **Migration Path** section below for the full TDD implementation plan with test-first steps.

1. **Phase 0 ‚Äî Infrastructure:** i18n library, locale setting, formatters, translation file structure, DB migration
2. **Phase 1 ‚Äî Auth:** Login, Register (first thing users see)
3. **Phase 2 ‚Äî Shell:** Layout (navigation), ErrorBoundary, common components
4. **Phase 3 ‚Äî Core pages:** Dashboard, Calendar, Customers, CustomerDetail
5. **Phase 4 ‚Äî Planning:** PlanningInbox, Planner, CandidateDetail, RouteDetailTimeline
6. **Phase 5 ‚Äî Secondary:** Settings, Jobs, Routes, WorkLog, Import/Export
7. **Phase 6 ‚Äî Stores, services, utils:** Zustand stores, service functions, utilities
8. **Phase 7 ‚Äî Shared types:** Label records, import aliases
9. **Phase 8 ‚Äî Backend:** NATS response messages, email templates, export
10. **Phase 9 ‚Äî Verification & cleanup:** Key parity, dead code removal, final visual check

---
---

# Part 2: Architecture Design

## Design Principles

1. **Zero-overhead default.** English (`en`) is the default. Performance favors English (preload `en`; see Architecture Clarifications).
2. **Progressive extraction.** Files can be migrated one at a time. Hardcoded Czech and `t()` calls coexist during migration.
3. **Type-safe keys.** Every translation key is checked at build time. A typo or missing key is a TypeScript error.
4. **One source of truth per string.** Each string lives in exactly one namespace file. Components import keys, never raw text.
5. **Backend stays English-keyed.** The Rust backend sends machine-readable codes/keys. The frontend resolves them to the user's locale. This avoids i18n complexity in Rust entirely.
6. **Locale follows the user.** Stored in user profile (DB), falls back to browser `navigator.language`, then to `en`.

---

## Technology Choice: `react-i18next`

| Criterion | react-i18next | react-intl (FormatJS) | DIY |
|-----------|:---:|:---:|:---:|
| Bundle size (gzip) | ~10 kB | ~14 kB | 0 |
| Pluralization (ICU) | ‚úÖ via plugin | ‚úÖ native | manual |
| Namespace splitting | ‚úÖ native | ‚ùå flat only | manual |
| Lazy loading per ns | ‚úÖ native | ‚ùå | manual |
| TypeScript key safety | ‚úÖ with `i18next-resources-to-backend` | partial | full |
| Zustand integration | trivial (detector) | context only | trivial |
| React 19 support | ‚úÖ | ‚úÖ | n/a |
| Ecosystem (tools, extractors) | largest | large | none |
| Vite plugin | `vite-plugin-i18next-loader` | ‚ùå | n/a |

**Decision: `i18next` + `react-i18next`** ‚Äî best namespace/lazy-loading support, largest ecosystem, simplest Zustand integration.

---

## Locale Resolution Chain

**Logged-in user:**
```
User DB setting (locale field on users table)
  ‚Üí Zustand authStore.user.locale
    ‚Üí navigator.language (mapped to supported locale)
      ‚Üí 'en'  (hardcoded fallback)
```

**Pre-login / post-logout:** Use `navigator.language`, map to supported locale, fall back to `en` if unsupported.

When a user logs in, `locale` from the JWT/user object is written to the i18n instance. Changing locale in Settings triggers both a DB update and an `i18n.changeLanguage()`.

**Supported locales (initial):** `en`, `en-GB`, `en-US`, `cs` ‚Äî regional variants (`en-GB`, `en-US`) share `en/*.json` files initially; i18next falls back to `en` when locale-specific files are absent.
**Later:** `sk`, `de`, `pl` (based on market expansion)

---

## File Structure

Translation JSON files live in `public/locales/` so they are served at `/locales/{lng}/{ns}.json` (required by `i18next-http-backend`).

```
apps/web/
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ locales/
‚îÇ       ‚îú‚îÄ‚îÄ cs/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ common.json   ‚Üê shared: buttons, states, units, errors
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ auth.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ nav.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ planner.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ customers.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ calendar.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ settings.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ import.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ jobs.json
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ validation.json
‚îÇ       ‚îî‚îÄ‚îÄ en/               ‚Üê en-GB, en-US fall back to en/*.json initially
‚îÇ           ‚îú‚îÄ‚îÄ common.json
‚îÇ           ‚îú‚îÄ‚îÄ auth.json
‚îÇ           ‚îî‚îÄ‚îÄ ...  (same structure)
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ i18n/
        ‚îú‚îÄ‚îÄ index.ts          ‚Üê i18n instance setup
        ‚îú‚îÄ‚îÄ formatters.ts     ‚Üê date/time/number formatting
        ‚îî‚îÄ‚îÄ types.ts          ‚Üê generated type from keys (strict mode, optional)
```

**Scope:** This structure applies to `apps/web` only. `apps/site` (marketing/landing) has its own i18n and is out of scope.

### Namespace design rationale

| Namespace | Approx. keys | Loaded when |
|-----------|:---:|-------------|
| `common` | ~100 | Always (buttons, units, status labels, generic errors) |
| `auth` | ~20 | Login/Register pages |
| `nav` | ~15 | Layout (always after auth) |
| `planner` | ~150 | PlanningInbox, Planner routes |
| `customers` | ~80 | Customers, CustomerDetail routes |
| `calendar` | ~40 | Calendar route |
| `settings` | ~80 | Settings route |
| `import` | ~60 | Import modal/report |
| `jobs` | ~30 | Jobs route |
| `validation` | ~30 | Any form |

Namespaces map roughly 1:1 to route-based code-split chunks. Loading a namespace is ~1-5 kB JSON per locale.

---

## i18n Instance Setup

```typescript
// apps/web/src/i18n/index.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

i18n
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    // Default and fallback (English per Architecture Clarifications)
    // Do NOT set `lng` ‚Äî let the detector chain resolve it
    fallbackLng: 'en',
    supportedLngs: ['en', 'en-GB', 'en-US', 'cs'],
    nonExplicitSupportedLngs: true,  // en-GB falls back to en when en-GB/*.json absent

    // Namespace config
    defaultNS: 'common',
    ns: ['common'],           // preload only common; rest loaded on demand
    fallbackNS: 'common',

    // Backend: HTTP loading; en is preloaded (smallest penalty for default locale)
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },

    // Language detector: check zustand store first, then browser, then fallback
    detection: {
      order: ['custom', 'navigator'],
      caches: [],  // we persist in DB, not localStorage
    },

    // TypeScript strict mode
    returnNull: false,
    interpolation: {
      escapeValue: false,   // React handles XSS
    },
  });

export default i18n;
```

---

## Integration with Zustand

No new store needed. Add `locale` field to the existing `UserPublic` type and read it from `authStore`:

```typescript
// Custom language detector plugin for i18next
const zustandDetector = {
  name: 'custom',
  lookup(): string | undefined {
    return useAuthStore.getState().user?.locale;
  },
};
```

When user changes locale in Settings:
1. `PATCH sazinka.settings.update-preferences` with `{ locale: 'en' }`
2. `i18n.changeLanguage('en')` ‚Äî triggers re-render of all translated components
3. `document.documentElement.lang = 'en'`

---

## Integration with React Components

### Hook pattern (most common)

```typescript
// Before:
<button>Ulo≈æit zmƒõny</button>

// After:
const { t } = useTranslation('settings');
<button>{t('save_changes')}</button>
```

### Component pattern (for rich text with JSX)

```typescript
<Trans i18nKey="planner:late_warning" values={{ time: '10:35', delay: 15 }}>
  P≈ô√≠jezd v {{ time }} ({{ delay }} min pozdƒõ) ‚Äî nutn√© domluvit nov√Ω ƒças
</Trans>
```

### Outside React (stores, utils, services)

```typescript
import i18n from '@/i18n';

// In Zustand store actions, service functions, etc.
const msg = i18n.t('errors.connection_lost', { ns: 'common' });
```

---

## Translation Key Convention

```
namespace:section.action_or_noun
```

Examples:

| Current Czech string | Key | Namespace |
|---------------------|-----|-----------|
| "Ulo≈æit zmƒõny" | `save_changes` | `common` |
| "Naƒç√≠t√°m..." | `loading` | `common` |
| "Nepoda≈ôilo se naƒç√≠st z√°kazn√≠ky" | `load_failed` | `customers` |
| "Chyb√≠ telefon" | `missing_phone` | `common` |
| "Odlo≈æit o den" | `snooze.one_day` | `planner` |
| "{{count}} z√°kazn√≠k≈Ø" | `customer_count` | `customers` |
| "1 rok" / "2 roky" / "5 let" | `duration.years` | `common` |
| "Po term√≠nu" | `status.overdue` | `common` |

### Pluralization (ICU)

```json
{
  "customer_count_one": "{{count}} z√°kazn√≠k",
  "customer_count_few": "{{count}} z√°kazn√≠ci",
  "customer_count_other": "{{count}} z√°kazn√≠k≈Ø",
  
  "duration_years_one": "{{count}} rok",
  "duration_years_few": "{{count}} roky",
  "duration_years_other": "{{count}} let"
}
```

i18next uses CLDR plural rules. Czech has: `one`, `few` (2-4), `other` (5+). Do not use `many`; use `other` for 5+.

---

## Shared Types Label Strategy

Current `DEVICE_TYPE_LABELS`, `REVISION_STATUS_LABELS`, etc. in `packages/shared-types/` are `Record<EnumValue, string>` with Czech values. These become translation keys:

```typescript
// Before (shared-types/device.ts):
export const DEVICE_TYPE_LABELS: Record<DeviceType, string> = {
  gas_boiler: 'Plynov√Ω kotel',
};

// After:
export const DEVICE_TYPE_KEYS: Record<DeviceType, string> = {
  gas_boiler: 'device_type.gas_boiler',
};

// In common.json (cs):
{ "device_type": { "gas_boiler": "Plynov√Ω kotel" } }

// In common.json (en):
{ "device_type": { "gas_boiler": "Gas boiler" } }

// Usage in component:
t(DEVICE_TYPE_KEYS[device.type])
```

This preserves type safety (key is always a valid DeviceType) while making labels translatable.

---

## Backend Strategy: Codes, Not Strings

The Rust backend currently sends Czech strings in NATS responses. The new approach:

### Backend key convention: colon namespace

Backend keys use the **i18next colon convention** ‚Äî `"namespace:key.path"`. This way `resolveBackendMessage()` can call `t(key, params)` directly and i18next resolves the namespace automatically. No separate `ns` parameter needed.

### Job status messages

```rust
// Before:
status_message: "Naƒç√≠t√°n√≠ z√°kazn√≠k≈Ø...".to_string()

// After (unified message shape, colon namespace):
status_message: json!({ "key": "jobs:loading_customers", "params": {} })
```

### Validation / error messages

```rust
// Before:
anyhow!("Z√°kazn√≠k '{}' nenalezen", name)

// After:
json!({ "key": "import:errors.customer_not_found", "params": { "name": name } })
```

### Route warnings

```rust
// Before:
format!("{}: p≈ô√≠jezd v {} je po konci okna {}", name, arrival, window_end)

// After:
json!({ "key": "planner:warning.arrival_after_window", "params": { "name": name, "arrival": arrival, "windowEnd": window_end } })
```

All three resolve via `resolveBackendMessage(payload)` on the frontend ‚Äî see signature below.

### Email templates

Email templates are already user-editable in Settings. Add per-locale default templates:

```rust
// types/settings.rs ‚Äî default templates become a map:
fn default_email_templates(locale: &str) -> EmailTemplateSettings {
    match locale {
        "en" => EmailTemplateSettings { ... English defaults ... },
        _    => EmailTemplateSettings { ... Czech defaults ... },
    }
}
```

Users who have customized templates keep their version. Locale only affects the initial defaults for new accounts.

### `resolveBackendMessage()` ‚Äî frontend helper

```typescript
// apps/web/src/i18n/resolveBackendMessage.ts
import i18n from './index';

/** Backend sends either a legacy plain string or the unified { key, params } shape. */
type BackendMessage = string | { key: string; params?: Record<string, unknown> };

/**
 * Resolve a backend message to a user-visible string.
 * - Legacy plain string ‚Üí returned as-is.
 * - { key, params } ‚Üí translated via i18next (key uses colon convention, e.g. "jobs:loading").
 * - Translation miss ‚Üí returns the key in dev, a generic fallback in prod.
 */
export function resolveBackendMessage(message: BackendMessage): string {
  if (typeof message === 'string') return message;
  const { key, params } = message;
  const result = i18n.t(key, params ?? {});
  // i18next returns the key itself when translation is missing
  if (result === key) {
    if (import.meta.env.DEV) console.warn(`[i18n] missing key: ${key}`);
    return i18n.t('common:errors.unknown');
  }
  return result;
}
```

---

## Date/Time/Number Formatting

### Centralized formatters

```typescript
// apps/web/src/i18n/formatters.ts
import i18n from './index';

export function formatDate(date: Date | string, style: 'short' | 'long' = 'short'): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  const locale = i18n.language;
  return d.toLocaleDateString(locale, 
    style === 'short' 
      ? { day: 'numeric', month: 'numeric', year: 'numeric' }
      : { day: 'numeric', month: 'long', year: 'numeric' }
  );
}

export function formatTime(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' });
}

export function formatNumber(n: number, decimals = 0): string {
  return n.toLocaleString(i18n.language, { 
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals 
  });
}

export function formatDistance(km: number): string {
  return `${formatNumber(km, 1)} km`;
}

export function formatDuration(minutes: number): string {
  const h = Math.floor(minutes / 60);
  const m = minutes % 60;
  if (h === 0) return i18n.t('common:units.minutes', { count: m });
  if (m === 0) return i18n.t('common:units.hours', { count: h });
  return `${h}h ${m.toString().padStart(2, '0')}min`;
}

export function formatRelativeTime(date: Date): string {
  const rtf = new Intl.RelativeTimeFormat(i18n.language, { numeric: 'auto' });
  const diffMs = date.getTime() - Date.now();
  const diffMin = Math.round(diffMs / 60000);
  if (Math.abs(diffMin) < 60) return rtf.format(diffMin, 'minute');
  const diffHour = Math.round(diffMin / 60);
  if (Math.abs(diffHour) < 24) return rtf.format(diffHour, 'hour');
  const diffDay = Math.round(diffHour / 24);
  return rtf.format(diffDay, 'day');
}

// Weekday/month names ‚Äî no more hardcoded arrays
export function getWeekdayNames(style: 'short' | 'long' = 'short'): string[] {
  const locale = i18n.language;
  // Monday-first week
  return Array.from({ length: 7 }, (_, i) => {
    const d = new Date(2024, 0, i + 1); // 2024-01-01 is Monday
    return d.toLocaleDateString(locale, { weekday: style });
  });
}

export function getMonthNames(style: 'short' | 'long' = 'long'): string[] {
  const locale = i18n.language;
  return Array.from({ length: 12 }, (_, i) => {
    const d = new Date(2024, i, 1);
    return d.toLocaleDateString(locale, { month: style });
  });
}
```

This replaces all 30+ `toLocaleDateString('cs-CZ')` calls and the hardcoded `MONTH_NAMES` / `WEEKDAY_NAMES` arrays with a single locale-aware source.

---

## DB Schema Change

```sql
-- Add locale column to users table (default en per Architecture Clarifications)
ALTER TABLE users ADD COLUMN locale VARCHAR(10) NOT NULL DEFAULT 'en';
```

The `locale` field is included in the JWT payload and `UserPublic` type so it's available immediately on login without an extra query. `VARCHAR(10)` accommodates regional codes like `en-GB`.

---

## Testing Strategy

1. **Unit tests** keep using Czech strings directly (no i18n in test files). Tests assert on translation keys or use a test i18n instance with Czech loaded.
2. **Snapshot/visual tests** run in both `cs` and `en` to catch layout issues from longer English strings.
3. **Missing key detection:** i18next `saveMissing` option in dev mode logs any key that resolves to fallback, making it easy to find untranslated strings during migration.
4. **CI check:** A script compares `cs/*.json` and `en/*.json` key sets. Missing keys in `en` fail the build.

---

## Implementation Status

> Last updated: 2026-02-14

### Phase 0: Infrastructure ‚Äî ‚úÖ COMPLETE

| Step | Status | Notes |
|------|--------|-------|
| 0.1.1 i18n instance | ‚úÖ Done | `apps/web/src/i18n/index.ts` ‚Äî HttpBackend, LanguageDetector, initReactI18next, zustandDetector, `languageChanged` listener. |
| 0.1.1 tests | ‚úÖ 10/10 pass | `apps/web/src/i18n/index.test.ts` ‚Äî test i18n instance with in-memory resources + production config options check. |
| 0.1.2 Provider | ‚úÖ Done | `main.tsx` imports `./i18n`, wraps `<App>` in `<Suspense>`. |
| 0.1.3 Locale JSONs | ‚úÖ Done | `apps/web/public/locales/en/common.json` (36 keys) and `cs/common.json` (39 keys, incl. Czech `_few` plurals). |
| 0.2 Zustand detector | ‚úÖ Done | Inline in `i18n/index.ts` (reads `authStore.user.locale`). |
| 0.2.2 lang attribute | ‚úÖ Done | `i18n.on('languageChanged')` listener sets `document.documentElement.lang`. |
| 0.3 Formatters | ‚úÖ 28/28 pass | `i18n/formatters.ts` + `i18n/formatters.test.ts` ‚Äî `formatDate`, `formatTime`, `formatNumber`, `formatDistance`, `formatDuration`, `formatRelativeTime`, `getWeekdayNames`, `getMonthNames`. |
| 0.4 resolveBackendMessage | ‚úÖ 8/8 pass | `i18n/resolveBackendMessage.ts` + test ‚Äî legacy passthrough, `{ key, params }` translation, missing key fallback. |
| 0.5.1 Shared types | ‚úÖ Done | Added `locale: string` to `UserPublic` in `packages/shared-types/src/auth.ts`. Updated `authStore.test.ts` (3 test user objects). |
| 0.5.2 SQL migration | ‚úÖ Done | `worker/migrations/017_add_user_locale.sql` ‚Äî `ALTER TABLE users ADD COLUMN locale VARCHAR(10) NOT NULL DEFAULT 'en'`. |
| 0.5.3 Rust backend | ‚úÖ Done | Added `locale` field to `User` struct, `UserPublic` struct (+ `From<User>` impl), `UserWithSettings` struct. Updated `USER_COLUMNS`, settings query. Added `locale` to JWT `Claims` (with `#[serde(default)]`), `generate_token()` signature. Updated all 3 callers in `handlers/auth.rs` and all 7 test calls. 19/19 Rust auth tests pass. |
| 0.6 Key parity script | ‚úÖ Done | `scripts/check-i18n-keys.js` ‚Äî plural-suffix-aware comparison, exits 0 when base keys match. |

**Dependencies installed:** ‚úÖ `i18next@^25.8.7`, `i18next-browser-languagedetector@^8.2.1`, `i18next-http-backend@^3.0.2`, `react-i18next@^16.5.4`.

**Test summary:** 100 frontend tests across 8 files + 19 Rust auth tests, all passing.

### Pre-crash UI refactoring (fixed)

The previous session extracted route summary stats/actions into shared components (`RouteSummaryStats`, `RouteSummaryActions`). The crash left 4 TypeScript errors which have been fixed:
1. Created `utils/timeFormatters.ts` for the missing `formatMinutesHm` import.
2. Removed stale destructured props from `PlanningTimeline.tsx`.
3. Removed stale prop passes from `Planner.tsx` ‚Üí `<PlanningTimeline>`.
4. Replaced `result.route?.depotDeparture` (non-existent field) with computation from first stop's arrival time.

### Phase 1: Auth pages (Login, Register) ‚Äî ‚úÖ COMPLETE

| Step | Status | Notes |
|------|--------|-------|
| 1.1 Auth namespace | ‚úÖ Done | `en/auth.json` (26 keys) + `cs/auth.json` (26 keys). Key parity check passes. |
| 1.2 Login.tsx | ‚úÖ Done | All 10 hardcoded Czech strings replaced with `t()` calls. Auth store error messages also i18n-ized via `i18n.t()`. |
| 1.3 Register.tsx | ‚úÖ Done | All 13 hardcoded Czech strings replaced with `t()` calls. Added locale `<select>` with `en`/`cs` options. Changing locale switches form language in real-time via `i18n.changeLanguage()`. |
| 1.4 Locale on register | ‚úÖ Done | `Register.tsx` detects locale from `navigator.language`, user can change via `<select>`. Locale sent to backend in register payload. Rust `RegisterRequest` + `create_user()` updated to accept and persist `locale`. Auth store `register()` signature extended with optional `locale` param. |
| 1.5 Tests | ‚úÖ 13/13 pass | `Login.test.tsx` (6 tests): EN/CS rendering, no hardcoded Czech, language switching, placeholders. `Register.test.tsx` (7 tests): EN/CS rendering, locale selector with 2 options, language switch via selector, hint text, key parity. |

### Phase 2: Shell (Layout, Navigation, ErrorBoundary) ‚Äî ‚úÖ COMPLETE

| Step | Status | Notes |
|------|--------|-------|
| 2.1 Nav namespace | ‚úÖ Done | `en/nav.json` (28 keys) + `cs/nav.json` (28 keys). Key parity passes. |
| 2.2 Layout.tsx | ‚úÖ Done | All 20+ hardcoded strings replaced: nav links (√ó9 desktop + √ó10 mobile), active jobs, online/offline, logout, menu/close aria-labels. |
| 2.3 ErrorBoundary + ProtectedRoute | ‚úÖ Done | `ErrorBoundary.tsx`: 3 strings via `i18n.t()` (class component). `ProtectedRoute.tsx`: 2 strings via `useTranslation('nav')`. |
| 2.4 Common components | ‚úÖ Done | `CollapseButton.tsx`: expand/collapse titles via `t()`. `JobStatusTimeline.tsx`: `DEFAULT_STEPS` labels use i18n keys, position text interpolated. Tests updated (20/20 pass). |
| 2.5 index.html lang + title | ‚úÖ Done | `index.html`: `lang="en"` (default), generic title. `i18n/index.ts`: `languageChanged` listener now also updates `document.title` from `nav:page_title`. |
| 2.6 Tests | ‚úÖ 28/28 pass | `Layout.test.tsx` (8 tests): EN/CS nav labels, online/offline, logout, no hardcoded Czech, language switching, key parity. `JobStatusTimeline.test.tsx` (20 tests): all states, progress, custom steps, i18n Czech labels. |

### Phase 3: Core pages (Dashboard, Calendar, Customers, CustomerDetail) ‚Äî ‚úÖ COMPLETE

| Step | Status | Notes |
|------|--------|-------|
| 3.1 Calendar namespace | ‚úÖ Done | `en/calendar.json` (47 keys) + `cs/calendar.json` (47 keys). |
| 3.4 Customers namespace | ‚úÖ Done | `en/customers.json` (115 keys) + `cs/customers.json` (115 keys). |
| 3.8 Dashboard namespace | ‚úÖ Done | `en/dashboard.json` (44 keys) + `cs/dashboard.json` (44 keys). |
| 3.11 Common duration keys | ‚úÖ Done | Added years/months/zero_days to `common.json` (en + cs). Key parity passes. |
| 3.2 Calendar.tsx | ‚úÖ Done | Removed MONTH_NAMES, formatShortDate, formatLongDate. Uses getMonthNames(), getWeekdayNames(), formatDate() from formatters. All ~50 strings via t(). |
| 3.3 CalendarGrid + DayCell | ‚úÖ Done | CalendarGrid uses getWeekdayNames('short'). DayCell uses t() for status titles, type labels, item counts. |
| 3.5 Customers.tsx | ‚úÖ Done | All ~40 strings via t(). formatRevisionStatus uses t() with interpolation. toLocaleDateString replaced with formatDate(). |
| 3.6 CustomerForm + AddCustomerForm | ‚úÖ Done | CustomerForm: ~30 strings. AddCustomerForm: ~15 strings. All form labels, placeholders, buttons via t(). |
| 3.7 CustomerSummary.tsx | ‚úÖ Done | ~31 strings via t(). toLocaleString('cs-CZ') replaced with formatNumber(). |
| 3.8b Dashboard.tsx | ‚úÖ Done | All ~40 strings via t(). Status labels use calendar namespace. |
| 3.9 DeleteConfirmDialog + CustomerHeader | ‚úÖ Done | DeleteConfirmDialog uses dangerouslySetInnerHTML for HTML interpolation. CustomerHeader: 8 strings via t(). |
| 3.10 toLocaleDateString replacements | ‚úÖ Done | Replaced in Customers.tsx and CustomerSummary.tsx (Phase 3 scope). |
| 3.11b overdueUtils.ts | ‚úÖ Done | Replaced manual Czech plural functions (formatYears/Months/Days) with i18n.t('common:duration.*', { count }). |
| 3.12 Tests | ‚úÖ Done | 543/548 pass. 5 pre-existing failures (not i18n-related). Global react-i18next mock in test/setup.ts. Tests with own i18n instance use vi.unmock(). |

**Test infrastructure changes:**
- `test/setup.ts`: Added global partial mock for `react-i18next` (useTranslation returns key) and `@/i18n` (mock i18n instance).
- Tests with their own i18n instance (`Layout.test.tsx`, `JobStatusTimeline.test.tsx`, `Login.test.tsx`, `Register.test.tsx`, `index.test.ts`) use `vi.unmock()` to restore real modules.
- `overdueUtils.test.ts`: Local mock for `@/i18n` with English-like output for testing.
- Updated assertions in `Calendar.test.tsx`, `Customers.test.tsx`, `Dashboard.test.tsx`, `CustomerDetail.test.tsx`, `DayCell.test.tsx`, `DeleteConfirmDialog.test.tsx`, `authStore.test.ts`.

**Phase 3 totals:** 6 namespaces, ~304 keys (47 calendar + 115 customers + 44 dashboard + 41 common + 29 nav + 28 auth). 543 tests passing across 35 test files.

### Phases 4‚Äì9: ‚ùå Not started

---

## Migration Path (file-by-file, no big bang)

> **Approach:** TDD (Red ‚Üí Green ‚Üí Refactor) for every step. Tests are written first; implementation follows. Each phase is independently deployable.

---

### Phase 0: Infrastructure

**Goal:** i18n plumbing in place; zero functional change; app still shows Czech.

#### 0.1 i18n instance & provider

| Step | TDD: Red (write test) | Green (implement) |
|------|----------------------|-------------------|
| 0.1.1 | Test: `i18n/index.ts` exports an initialized i18next instance with `fallbackLng: 'en'`, `supportedLngs` includes `['en','en-GB','en-US','cs']`, `nonExplicitSupportedLngs: true`. | Create `apps/web/src/i18n/index.ts` with full config (no `lng`, detector chain, HTTP backend). |
| 0.1.2 | Test: `<App>` renders inside `<I18nextProvider>` (or `<Suspense>` wrapping). | Wrap `<App>` in `main.tsx` with i18n provider; add `<Suspense fallback>` for async loading. |
| 0.1.3 | Test: `en/common.json` and `cs/common.json` exist, are valid JSON, and have identical key sets. | Create `apps/web/public/locales/en/common.json` and `cs/common.json` with initial keys: `loading`, `save`, `cancel`, `delete`, `confirm`, `error`, `status.overdue`, `units.km`, `units.min`, `units.hours`. |

#### 0.2 Zustand language detector

| Step | TDD: Red | Green |
|------|---------|-------|
| 0.2.1 | Test: `zustandDetector.lookup()` returns `user.locale` from `authStore` when logged in; returns `undefined` when no user. | Implement custom i18next language detector plugin. |
| 0.2.2 | Test: on `i18n.changeLanguage('cs')`, `document.documentElement.lang` updates to `'cs'`. | Add `i18n.on('languageChanged')` listener in init. |

#### 0.3 Formatters

| Step | TDD: Red | Green |
|------|---------|-------|
| 0.3.1 | Test: `formatDate('2026-03-15', 'short')` returns locale-appropriate string for `en` and `cs`. | Implement `formatDate()` in `i18n/formatters.ts`. |
| 0.3.2 | Test: `formatTime('2026-03-15T14:30:00')` returns `'2:30 PM'` for `en`, `'14:30'` for `cs`. | Implement `formatTime()`. |
| 0.3.3 | Test: `formatNumber(1234.5, 1)` returns `'1,234.5'` for `en`, `'1 234,5'` for `cs`. | Implement `formatNumber()`. |
| 0.3.4 | Test: `formatDistance(12.3)` returns `'12.3 km'` for `en`, `'12,3 km'` for `cs`. | Implement `formatDistance()`. |
| 0.3.5 | Test: `formatDuration(125)` returns `'2h 05min'`. | Implement `formatDuration()`. |
| 0.3.6 | Test: `formatRelativeTime(new Date(Date.now() - 3600000))` returns a string containing "hour" (en) or "hodin" (cs). | Implement `formatRelativeTime()`. |
| 0.3.7 | Test: `getWeekdayNames('short')` returns 7 items, first is Monday equivalent. `getMonthNames()` returns 12 items. | Implement `getWeekdayNames()`, `getMonthNames()`. |

#### 0.4 resolveBackendMessage

| Step | TDD: Red | Green |
|------|---------|-------|
| 0.4.1 | Test: `resolveBackendMessage('Naƒç√≠t√°m...')` returns `'Naƒç√≠t√°m...'` (legacy passthrough). | Implement `resolveBackendMessage()` in `i18n/resolveBackendMessage.ts`. |
| 0.4.2 | Test: `resolveBackendMessage({ key: 'common:loading', params: {} })` returns translated string. | Handle `{ key, params }` shape. |
| 0.4.3 | Test: `resolveBackendMessage({ key: 'unknown:missing_key' })` returns generic fallback, does not throw. | Handle missing key gracefully. |

#### 0.5 DB & shared types

| Step | TDD: Red | Green |
|------|---------|-------|
| 0.5.1 | Test: `UserPublic` type includes `locale: string`. | Add `locale` field to `UserPublic` in `packages/shared-types/src/auth.ts`. |
| 0.5.2 | Backend: SQL migration test (if applicable) or manual verification. | Create SQL migration: `ALTER TABLE users ADD COLUMN locale VARCHAR(10) NOT NULL DEFAULT 'en'`. |
| 0.5.3 | Test: Rust `User` struct includes `locale` field; login response contains it. | Update Rust `User` struct, auth handler, JWT claims. |

#### 0.6 Translation key parity script

| Step | TDD: Red | Green |
|------|---------|-------|
| 0.6.1 | Test: Script exits 0 when `en` and `cs` keys match; exits 1 when they differ. | Create `scripts/check-i18n-keys.ts` (or `.js`) that compares key sets across locale folders. |

**Phase 0 done criteria:** App boots, shows existing Czech UI unchanged. i18n instance initializes. Formatters pass all tests. Parity script passes. `locale` field exists in DB and types.

---

### Phase 1: Auth pages (Login, Register)

**Goal:** First user-visible i18n ‚Äî the entry point of the app.

| Step | TDD: Red | Green |
|------|---------|-------|
| 1.1 | Test: `en/auth.json` and `cs/auth.json` exist with identical keys. | Create namespace files with keys for Login + Register. |
| 1.2 | Test: `Login.tsx` renders `t('auth:login_title')` text, not hardcoded Czech. | Replace hardcoded strings in `Login.tsx` with `t()` calls. |
| 1.3 | Test: `Register.tsx` renders `t('auth:register_title')`, locale selector is present. | Replace strings in `Register.tsx`; add locale confirmation UI. |
| 1.4 | Test: On register, `user.locale` is set from browser language (mapped to supported). | Wire registration form to set `locale` from `navigator.language`. |
| 1.5 | Test: Switching language on login page re-renders all visible text. | Verify `useTranslation('auth')` reactivity. |

**Phase 1 done criteria:** Login and Register render in English by default. Czech user sees Czech after locale detection. ~20 keys in `auth` namespace.

---

### Phase 2: Shell (Layout, Navigation, ErrorBoundary)

**Goal:** All persistent UI chrome is translated.

| Step | TDD: Red | Green |
|------|---------|-------|
| 2.1 | Test: `en/nav.json` and `cs/nav.json` exist with identical keys. | Create namespace files. |
| 2.2 | Test: Sidebar/navigation items render from `t('nav:...')` keys. | Replace hardcoded nav labels. |
| 2.3 | Test: `ErrorBoundary` renders `t('common:errors...')` messages. | Replace hardcoded error messages. |
| 2.4 | Test: Common components (`CollapseButton`, `ConfirmDialog`, etc.) use `t()`. | Replace hardcoded strings in common components. |
| 2.5 | Test: `<html lang=...>` attribute updates when language changes. | Verify `languageChanged` listener from Phase 0 works end-to-end. |
| 2.6 | Test: `<title>` updates dynamically based on locale. | Replace hardcoded `<title>`. |

**Phase 2 done criteria:** Navigation, error states, and all shared chrome render in the active locale. ~15 keys in `nav`.

---

### Phase 3: Core pages (Dashboard, Calendar, Customers, CustomerDetail)

**Goal:** Main daily-use screens are fully translated.

| Step | TDD: Red | Green |
|------|---------|-------|
| 3.1 | Test: `en/calendar.json` and `cs/calendar.json` exist with identical keys. | Create namespace files. |
| 3.2 | Test: `Calendar.tsx` uses `getMonthNames()` and `getWeekdayNames()` from formatters, not hardcoded arrays. | Replace `MONTH_NAMES`, `WEEKDAY_NAMES`. |
| 3.3 | Test: `CalendarGrid.tsx` renders weekday headers from `getWeekdayNames('short')`. | Replace hardcoded array. |
| 3.4 | Test: `en/customers.json` and `cs/customers.json` exist with identical keys. | Create namespace files. |
| 3.5 | Test: `Customers.tsx` filter labels, empty states, and error messages use `t()`. | Replace hardcoded strings. |
| 3.6 | Test: `CustomerForm.tsx` renders all form labels/placeholders from `t()`. | Replace ~18 form labels. |
| 3.7 | Test: `CustomerSummary.tsx` stats labels use `t()`. | Replace hardcoded labels. |
| 3.8 | Test: `Dashboard.tsx` status labels and stats use `t()`. | Replace hardcoded strings. |
| 3.9 | Test: `DeleteConfirmDialog.tsx` uses `t()` for confirm/cancel text. | Replace hardcoded strings. |
| 3.10 | Test: All `toLocaleDateString('cs-CZ')` calls in these files replaced with `formatDate()`/`formatTime()`. | Replace date formatting calls. |
| 3.11 | Test: `overdueUtils.ts` pluralization uses `t('common:duration...')` with `{ count }`. | Replace manual Czech plural logic with i18next pluralization. |

**Phase 3 done criteria:** Dashboard, Calendar, Customers, CustomerDetail render in active locale. Czech plurals work via i18next. ~120 keys across `calendar` and `customers` namespaces.

---

### Phase 4: Planning (PlanningInbox, Planner, CandidateDetail, RouteDetailTimeline) ‚úÖ COMPLETE

**Goal:** The most string-heavy area of the app is translated.

| Step | TDD: Red | Green | Status |
|------|---------|-------|--------|
| 4.1 | Test: `en/planner.json` and `cs/planner.json` exist with identical keys. | Create namespace files (~150 keys). | ‚úÖ 257 keys (256 base), key parity PASSED |
| 4.2 | Test: `PlanningInbox.tsx` filter presets, labels, tooltips use `t()`. | Replace ~50 strings. | ‚úÖ ~60 strings replaced, `formatDate`/`getMonthNames`/`getWeekdayNames` used for dates |
| 4.3 | Test: `planningInboxFilters.ts` preset labels use `t()`. | Replace filter labels. | ‚úÖ FILTER_PRESETS use i18n keys, `buildFilterSummary` uses `i18n.t()` |
| 4.4 | Test: `CandidateDetail.tsx` state flags, buttons, snooze labels use `t()`. | Replace strings. | ‚úÖ ~40 strings replaced, `formatDate` for dates |
| 4.5 | Test: `CandidateRow.tsx` metric labels, tooltips use `t()`. | Replace strings. | ‚úÖ ~12 strings replaced |
| 4.6 | Test: `RouteDetailTimeline.tsx` stop labels, confirmations use `t()`. | Replace strings. | ‚úÖ ~20 strings replaced, `getStatusBadge`/`getWarningLabel` accept `t` |
| 4.7 | Test: `RouteListPanel.tsx` uses `formatDate()` and `t()` for units. | Replace hardcoded weekday array + "zast.", "min", "km". | ‚úÖ `getWeekdayNames('short')` replaces hardcoded array, 3 strings replaced |
| 4.8 | Test: `CapacityMetrics.tsx`, `DraftModeBar.tsx`, `SortableStopItem.tsx`, `SlotSuggestions.tsx` use `t()`. | Replace strings in remaining planner components. | ‚úÖ ~25 strings across 4 files |
| 4.9 | Test: `PlanningTimeline.tsx` late-arrival warning uses `t()` with interpolation. | Replace formatted warning string. | ‚úÖ Late arrival uses `t()` with `{ time, minutes }` interpolation |
| 4.10 | Test: `ProblemsSegment.tsx`, `VirtualizedInboxList.tsx` use `t()`. | Replace remaining strings. | ‚úÖ Plus 9 additional components: RouteMapPanel, AddFromInboxDrawer, ScheduledTimeWarning, InsertionPreview, RouteSummaryStats, RouteSummaryActions, TimelineViewToggle, MultiCrewTip, RouteContextHeader |

**Additional components internationalized (beyond original plan):**
- `Planner.tsx` ‚Äî error messages, section headers (~9 strings)
- `ScheduledTimeWarning.tsx` ‚Äî dialog title, message (with `dangerouslySetInnerHTML`), buttons (~5 strings)
- `RouteMapPanel.tsx` ‚Äî depot popup, preview popup, empty hint, segment info (~6 strings)
- `InsertionPreview.tsx` ‚Äî title, new stop label, impact label (~3 strings)
- `RouteSummaryStats.tsx` ‚Äî stat labels (~7 strings)
- `RouteSummaryActions.tsx` ‚Äî optimize, break, delete buttons (~4 strings)
- `TimelineViewToggle.tsx` ‚Äî view toggle titles (~2 strings)
- `MultiCrewTip.tsx` ‚Äî tip label, crew comparison (with `dangerouslySetInnerHTML`), switch button (~3 strings)
- `AddFromInboxDrawer.tsx` ‚Äî drawer title, candidate list, slot selection, error messages (~12 strings)
- `RouteContextHeader.tsx` ‚Äî context selectors, weekday names (~8 strings)

**Phase 4 done criteria:** Entire Planning module renders in active locale. 257 keys in `planner` namespace (exceeded ~150 target). Czech pluralization for visit counts (`_one`, `_few`, `_other`).

**Test results:** 544/548 passing. 4 pre-existing failures (2 √ó `customerService.test.ts` payload mismatch, 2 √ó `CandidateDetail.test.tsx` DOM order). All i18n-related tests updated and passing.

---

### Phase 5: Secondary pages (Settings, Jobs, Routes, WorkLog, Import/Export)

**Goal:** All remaining frontend pages translated.

| Step | TDD: Red | Green |
|------|---------|-------|
| 5.1 | Test: `en/settings.json`, `en/import.json`, `en/jobs.json` and their `cs` counterparts exist with identical keys. | Create namespace files. |
| 5.2 | Test: `Settings.tsx` tabs, labels, CRUD messages use `t()`. | Replace ~60 strings. |
| 5.3 | Test: `Jobs.tsx` status labels, relative time use `t()` and `formatRelativeTime()`. | Replace strings. |
| 5.4 | Test: `Routes.tsx` tooltips and errors use `t()`. | Replace strings. |
| 5.5 | Test: `WorkLog.tsx`, `VisitDetail.tsx`, `RevisionDetail.tsx` use `t()`. | Replace strings. |
| 5.6 | Test: `ImportCustomersModal.tsx`, `ImportReportDialog.tsx` use `t()`. | Replace strings. |
| 5.7 | Test: `exportService.ts` CSV column headers use `t()`. | Replace ~16 hardcoded CSV labels. |
| 5.8 | Test: `CallQueue.tsx` labels and buttons use `t()`. | Replace strings. |
| 5.9 | Test: `Admin.tsx`, `About.tsx` use `t()`. | Replace strings. |
| 5.10 | Test: `useKeyboardShortcuts.ts` descriptions use `t()`. | Replace ~10 shortcut labels. |
| 5.11 | Test: `en/validation.json` and `cs/validation.json` exist with identical keys. | Create namespace files. |
| 5.12 | Test: `customerValidation.ts` messages use `t()`. | Replace validation messages. |
| 5.13 | Test: Import alias maps accept English aliases alongside Czech. | Extend alias maps in shared-types. |

**Phase 5 done criteria:** All frontend pages and services render in active locale. ~170 keys across `settings`, `import`, `jobs`, `validation` namespaces.

---

### Phase 6: Stores, services, utilities

**Goal:** Non-React code (Zustand stores, service functions, utils) uses i18n.

| Step | TDD: Red | Green |
|------|---------|-------|
| 6.1 | Test: `authStore.ts` error messages use `i18n.t()`. | Replace 3 hardcoded error strings. |
| 6.2 | Test: `activeJobsStore.ts` job type names use `i18n.t()`. | Replace job type labels. |
| 6.3 | Test: `natsStore.ts` connection error messages use `i18n.t()`. | Replace 2 error strings. |
| 6.4 | Test: `calendarService.ts`, `visitService.ts`, `communicationService.ts` labels use `i18n.t()`. | Replace service-level labels. |
| 6.5 | Test: `insertionService.ts` format strings use `i18n.t()`. | Replace "+Xmin / +Ykm" patterns. |
| 6.6 | Test: `breakUtils.ts` unit labels use `i18n.t()`. | Replace "km", "min" strings. |

**Phase 6 done criteria:** No hardcoded Czech in stores, services, or utils. ~25 keys moved to existing namespaces.

---

### Phase 7: Shared types (label records, import aliases)

**Goal:** `packages/shared-types` label maps become i18n key maps.

| Step | TDD: Red | Green |
|------|---------|-------|
| 7.1 | Test: `DEVICE_TYPE_KEYS` maps each `DeviceType` to a `common:device_type.*` key; `t(key)` resolves. | Rename `DEVICE_TYPE_LABELS` ‚Üí `DEVICE_TYPE_KEYS`; add keys to `common.json`. |
| 7.2 | Test: `WORK_TYPE_KEYS`, `WORK_RESULT_KEYS` map correctly. | Same pattern. |
| 7.3 | Test: `ROUTE_STATUS_KEYS`, `REVISION_STATUS_KEYS`, `REVISION_RESULT_KEYS` map correctly. | Same pattern. |
| 7.4 | Test: `PAGE_PERMISSIONS`, `SETTINGS_PERMISSIONS` labels use keys. | Same pattern. |
| 7.5 | Test: All components that previously used `*_LABELS[value]` now use `t(*_KEYS[value])`. | Update all call sites (~20 files). |
| 7.6 | Test: Import alias maps include English aliases for all enum types. | Extend `DEVICE_TYPE_ALIASES`, `REVISION_STATUS_ALIASES`, etc. |

**Phase 7 done criteria:** No Czech strings in `packages/shared-types`. All labels resolved via i18n. ~50 keys added to `common.json`.

---

### Phase 8: Backend key migration

**Goal:** Rust backend sends `{ key, params }` instead of Czech strings.

| Step | TDD: Red | Green |
|------|---------|-------|
| 8.1 | Test (Rust): Job progress messages are valid `{ key, params }` JSON. | Replace ~20 `status_message` strings in `jobs.rs`. |
| 8.2 | Test (Rust): Import error messages use `{ key, params }` shape. | Replace ~30 messages in `import_processors.rs`, `import.rs`. |
| 8.3 | Test (Rust): Route warnings use `{ key, params }` shape. | Replace ~10 messages in `vrp/pragmatic.rs`, `vrp/mod.rs`. |
| 8.4 | Test (Rust): Slot/insertion messages use `{ key, params }` shape. | Replace ~10 messages in `slots.rs`, `insertion.rs`. |
| 8.5 | Test (Rust): Export progress messages use `{ key, params }` shape. | Replace ~5 messages in `export_processor.rs`. |
| 8.6 | Test (Frontend): `resolveBackendMessage()` correctly translates all new backend keys. | Verify frontend handles all new keys; add missing keys to JSON. |
| 8.7 | Test (Rust): Default email templates are locale-aware (en defaults for new accounts). | Implement `default_email_templates(locale)` in `types/settings.rs`. |
| 8.8 | Test (Rust): Mixed English backend messages ("Database reset successfully", etc.) converted to keys. | Unify remaining English messages. |

**Phase 8 done criteria:** Backend sends only keys + params. Zero Czech strings in Rust user-facing messages. ~120 keys added to various namespaces.

---

### Phase 9: Final verification & cleanup

**Goal:** Verify completeness; remove dead code.

| Step | TDD: Red | Green |
|------|---------|-------|
| 9.1 | Test: Parity script passes for all namespace files across `en` and `cs`. | Fix any missing keys. |
| 9.2 | Test: `grep -r "cs-CZ" apps/web/src/` returns zero matches. | Remove any remaining hardcoded `'cs-CZ'` locale strings. |
| 9.3 | Test: `grep -r "toLocaleDateString\|toLocaleTimeString\|toLocaleString" apps/web/src/` returns zero matches outside `formatters.ts`. | Replace any remaining direct Intl calls. |
| 9.4 | Test: No Czech string literals remain in `apps/web/src/**/*.{ts,tsx}` (excluding test files and JSON). | Scan and fix stragglers. |
| 9.5 | Test: App renders correctly in `en` and `cs` (manual visual check or automated screenshot comparison). | Fix any layout issues from longer/shorter translated strings. |
| 9.6 | Remove old `*_LABELS` exports from shared-types (if any consumers remain, update them). | Clean up dead exports. |
| 9.7 | Update `index.html` `<title>` and `lang` attribute to be dynamic. | Already done via Phase 0 listener; verify. |

**Phase 9 done criteria:** Zero hardcoded Czech in frontend code. Zero `'cs-CZ'` literals. Full key parity. Clean build.

---

### Estimated effort per phase

| Phase | Description | Est. keys | Est. effort |
|:-----:|-------------|:---------:|:-----------:|
| 0 | Infrastructure | ~15 | 1 day |
| 1 | Auth (Login, Register) | ~20 | 0.5 day |
| 2 | Shell (Nav, Layout, common) | ~15 | 0.5 day |
| 3 | Core pages (Dashboard, Calendar, Customers) | ~120 | 2 days |
| 4 | Planning (Inbox, Planner, Timeline) | ~150 | 2 days |
| 5 | Secondary pages (Settings, Jobs, Import) | ~170 | 2 days |
| 6 | Stores, services, utils | ~25 | 0.5 day |
| 7 | Shared types | ~50 | 1 day |
| 8 | Backend keys | ~120 | 2 days |
| 9 | Verification & cleanup | ‚Äî | 0.5 day |
| **Total** | | **~685** | **~12 days** |

---

## What This Architecture Does NOT Include (consciously)

| Concern | Decision | Rationale |
|---------|----------|-----------|
| RTL support | Excluded | No Arabic/Hebrew market planned |
| Currency formatting | Excluded | App doesn't handle payments |
| Timezone handling | Excluded | All times are local CZ; revisit when multi-country |
| Translation management (Crowdin, Lokalise) | Deferred | With 2 languages and 1 developer, JSON files in git are sufficient. Add a TMS when >3 languages or external translators are involved. |
| Server-side rendering i18n | N/A | App is SPA |
| Per-tenant locale | Excluded | Locale is per-user, not per-organization |

---

## Key Design Decisions (Confirmed by User)

1.  **Routing Strategy:** **State-based routing** (e.g., `/planning`) over URL-based routing (`/cs/planning`).
    *   *Rationale:* Simpler implementation, better UX for logged-in CRM users, cleaner URLs. SEO is irrelevant for this private app.
2.  **Date Libraries:** **None**. Use native `Intl` APIs.
    *   *Rationale:* Modern browsers support `Intl.DateTimeFormat` and `Intl.RelativeTimeFormat` natively. No extra bundle size needed.
3.  **Locale Storage:** **Database (User Profile)**.
    *   *Rationale:* Critical for offline background workers (sending emails in the correct language) and cross-device synchronization.

---

## Architecture Clarifications (Final Decisions)

This section supersedes earlier assumptions where they conflict.

### Locale strategy

1. **Supported locales from day one include regional variants** (e.g. `en`, `en-GB`, `en-US`).
2. **Default locale is English** (`en`).
3. **Fallback locale is English** (`en`) for unsupported/missing locales.
4. **Performance bias for English:** Use HTTP loading only; `en` is preloaded early. No bundling of translations into the main chunk.
5. **Routing remains state-based** (no locale in URL).
6. **Regional locale files:** Start with shared `en/*.json` only; `en-GB` and `en-US` fall back to `en` via i18next. Add locale-specific overrides later if needed.

### Backend-to-frontend i18n message contract

Use a **unified message shape** across all backend user-facing responses (jobs, warnings, errors, import/export progress):

```json
{
  "key": "jobs:loading_customers",
  "params": {
    "count": 42
  }
}
```

- `key`: translation key using **i18next colon convention** (`namespace:key.path`)
- `params`: optional interpolation parameters

Decision: **frontend-only fallback logic** during migration (backend does not provide localized fallback text payloads).

### Frontend fallback behavior (migration period)

If a backend message cannot be translated:
1. Try to resolve by `key`.
2. If key is missing/unknown, render a safe fallback in frontend (never break UI).
3. Avoid leaking raw technical data to users; keep dev diagnostics in logs only.

### Import strategy for existing Czech CSV files

Context: DB will be re-created; import files stay unchanged and contain Czech names/strings with no locale metadata.

Decisions:
1. **Import parser accepts aliases from all supported locales** (tolerant mode).
2. **When source locale is missing, assume Czech CSV semantics by default** for alias matching priority.
3. Parse all localized aliases into **canonical internal enum/code values**.
4. Do not translate free-text payload fields from CSV (names, addresses, notes remain source text).

### Email template policy

1. Existing user email templates are **never auto-modified** on locale changes.
2. Locale affects only defaults for newly created accounts (or explicitly reset templates).

### Shared-types localization strategy

Use **Option A**:
- keep translation key maps in `packages/shared-types` (e.g. `DEVICE_TYPE_KEYS`, `REVISION_STATUS_KEYS`, etc.)
- frontend resolves those keys via i18n.

Rationale: pragmatic and simple in monorepo context; minimizes adapter duplication.

### CI/testing approach

Use the **simpler approach**:
1. Keep migration checks lightweight in early phases.
2. Add strict parity checks (`cs` vs `en` key sets) once namespace extraction is active for a module.

### Registration locale flow

On registration:
1. Set initial `user.locale` from `navigator.language` (mapped to a supported locale).
2. **Ask the user during registration to confirm or change** the locale before completing signup.

### apps/site scope

`apps/site` (marketing/landing page) is **separate** ‚Äî we are not changing its architecture. See the dedicated section below for relationship analysis and integration options.

### Backend message envelope (frontend handling)

During migration the backend may send either:
- **Legacy:** plain string (e.g. Czech "Naƒç√≠t√°m z√°kazn√≠ky...").
- **New:** `{ key: string, params?: Record<string, unknown> }`.

Frontend `resolveBackendMessage()` logic:
- If payload is an object with `key`, translate via `t(key, params)`.
- If payload is a plain string, display as-is (legacy).
- If translation fails, render a safe fallback; log in dev only.

---

## Relationship: `apps/site` vs `apps/web` i18n

### `apps/site` architecture (not changing)

| Aspect | Detail |
|--------|--------|
| **Framework** | Astro 5 (static output, `output: 'static'`) |
| **Hosting** | Cloudflare Pages + Page Functions (D1 database) |
| **Rendering** | Pre-generated static HTML at build time |
| **Routing** | URL-based locale prefixes: `/en/`, `/cs/`, `/sk/` (SEO-required) |
| **Locale detection** | Root `/` redirects via JS (`navigator.language`) + `<meta http-equiv="refresh">` fallback to `/en/` |
| **i18n library** | None. Custom `getTranslation(locale, key)` function with dot-path traversal |
| **Translation files** | 3 flat JSON files: `src/i18n/en.json`, `cs.json`, `sk.json` (~107 keys each) |
| **Translation delivery** | Compiled into HTML at build time (zero runtime cost) |
| **Supported locales** | `en`, `cs`, `sk` (configured in `astro.config.mjs`) |
| **Default locale** | `en` (matches `apps/web`) |
| **React components** | `ContactForm.tsx`, `NewsletterForm.tsx` ‚Äî receive labels as props from Astro parent |
| **Backend** | Cloudflare Page Functions (`functions/api/contact.ts`, `newsletter.ts`) ‚Äî no i18n strings, just API |
| **Testing** | Key parity test ensures `cs` and `sk` keys match `en` |
| **Link to app** | Hardcoded `https://app.ariadline.com` in CTA buttons |

### Key architectural differences

| Dimension | `apps/site` | `apps/web` |
|-----------|-------------|------------|
| **i18n approach** | Build-time (Astro SSG) | Runtime (i18next in SPA) |
| **Locale in URL** | Yes (`/cs/pricing`) ‚Äî required for SEO | No ‚Äî state-based (user DB setting) |
| **Translation loading** | Compiled into HTML | HTTP-fetched JSON at runtime |
| **Locale storage** | URL path segment | User DB profile |
| **Locale count** | 3 (`en`, `cs`, `sk`) | 4+ (`en`, `en-GB`, `en-US`, `cs`) |
| **Pluralization** | Not needed (marketing copy) | Required (Czech plural rules) |
| **Translation format** | Flat nested JSON, ~107 keys | Namespaced JSON, ~775 keys |
| **Library** | Custom 35-line `utils.ts` | `i18next` + `react-i18next` |

### What they share today

1. **Default locale:** Both default to `en`.
2. **JSON structure:** Both use nested JSON with dot-path keys (e.g. `nav.home`, `hero.title`).
3. **No key overlap:** `apps/site` keys are marketing-specific (`hero`, `pricing`, `cta`, `newsletter`); `apps/web` keys are app-specific (`planner`, `customers`, `settings`). Zero collision.
4. **Domain terms:** A few terms appear in both contexts with the same meaning: "Features" / "Funkce", "Pricing" / "Cen√≠k", "Contact" / "Kontakt". These are independently maintained (different copy/tone).

### Integration options

#### Option A: Fully separate (current state, recommended)

Keep both i18n systems completely independent. Each app owns its translation files, tooling, and locale list.

| Pro | Con |
|-----|-----|
| Zero coupling ‚Äî deploy independently | Duplicate translations for ~5 shared terms |
| No risk of site breakage from app i18n changes | Adding a new locale requires changes in both apps |
| `apps/site` build-time approach is optimal for SEO/performance | ‚Äî |
| Different locale sets are natural (site has `sk`, app doesn't yet) | ‚Äî |

#### Option B: Shared glossary package

Create `packages/i18n-glossary/` with a small set of shared terms (brand name, product terms, common labels). Both apps import from it.

| Pro | Con |
|-----|-----|
| Single source of truth for brand terms | New package to maintain |
| Ensures consistent terminology | Coupling: glossary change triggers rebuild of both apps |
| ‚Äî | Marginal benefit (~5 shared terms) |

#### Option C: Shared locale config only

Create a tiny `packages/i18n-config/` exporting only `SUPPORTED_LOCALES`, `DEFAULT_LOCALE`, and locale metadata (display names, BCP-47 codes). Translation files stay separate.

| Pro | Con |
|-----|-----|
| Adding a new locale is coordinated | Minimal benefit over just documenting the convention |
| Type-safe locale type shared across monorepo | Another package dependency |

### Decision: Option A ‚Äî Fully separate (confirmed by user)

**Option A (fully separate)** is the right choice. Reasons:

1. The two apps have fundamentally different i18n architectures (build-time vs runtime) for good reasons.
2. There are fewer than 5 shared terms ‚Äî not enough to justify coupling.
3. `apps/site` already supports `sk`, which `apps/web` doesn't. Independent locale lists are a feature, not a bug.
4. The only coordination needed is a convention: "default locale is `en` in both apps." This is documented, not coded.

### Cross-app user flow: site ‚Üí app

When a user clicks "Try for free" on the marketing site (`https://ariadline.com/cs/`), they land on `https://app.ariadline.com`. Currently the link is locale-unaware ‚Äî it always goes to the app root.

**Future improvement (not Phase 0):** Pass the site locale to the app via query parameter:
- Site CTA links to `https://app.ariadline.com?lang=cs`
- App reads `lang` param on first load, uses it as initial locale hint (before login/registration)
- This ensures a Czech visitor from the marketing site sees the app in Czech before registering

This is a small enhancement that can be added later without architectural changes to either app.

---

## Notes on Changes vs Earlier Sections

These decisions update prior text in this document:
- Locale default/fallback changed from Czech to **English**.
- Regional locale support is explicitly in scope from phase start; start with shared `en` files.
- Backend contract is standardized to one message shape (`key`, `params`).
- Import behavior is explicitly tolerant and compatible with Czech legacy CSV inputs.
- Performance: HTTP loading with preload for `en` (no bundling).
- Registration: locale from browser, user confirms/changes during signup.

