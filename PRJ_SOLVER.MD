# PRJ_SOLVER â€” Rezerva pÅ™Ã­jezdu jako vlastnost trasy

## Stav: NÃVRH

Tento dokument popisuje pÅ™esun parametrÅ¯ â€rezerva pÅ™Ã­jezdu" (arrival buffer) z posÃ¡dky na trasu. Rezerva se stane vlastnostÃ­ konkrÃ©tnÃ­ trasy uloÅ¾enÃ© v DB, s automatickÃ½m pÅ™edvyplnÄ›nÃ­m z poslednÃ­ch pouÅ¾itÃ½ch hodnot uÅ¾ivatele.

---

## 1. Motivace

Dnes je rezerva pÅ™Ã­jezdu (`arrival_buffer_percent`, `arrival_buffer_fixed_minutes`) nastavena na posÃ¡dce. To je nepraktickÃ©:

- UÅ¾ivatel nemÅ¯Å¾e mÃ­t rÅ¯znÃ© rezervy pro rÅ¯znÃ© trasy tÃ©Å¾e posÃ¡dky.
- ZmÄ›na na posÃ¡dce zpÄ›tnÄ› ovlivnÃ­ interpretaci vÅ¡ech starÃ½ch tras.
- Rezerva je logicky vlastnost konkrÃ©tnÃ­ trasy, ne posÃ¡dky.

### CÃ­lovÃ½ stav

- Rezerva pÅ™Ã­jezdu je **vlastnost trasy** (`routes` tabulka).
- PÅ™i tvorbÄ› novÃ© trasy se automaticky pouÅ¾ije **poslednÃ­ pouÅ¾itÃ¡ hodnota** danÃ©ho uÅ¾ivatele (z `users` tabulky).
- Na timeline detailu trasy je rezerva **viditelnÄ› uvedena drobnÃ½m pÃ­smem** a **editovatelnÃ¡** po rozkliknutÃ­.
- Z posÃ¡dky se pole `arrival_buffer_percent` a `arrival_buffer_fixed_minutes` **odstranÃ­**.

---

## 2. InventÃ¡Å™ dotÄenÃ½ch mÃ­st

### 2.1 OdstranÄ›nÃ­ z posÃ¡dky (crew)

| Soubor | Co odebrat |
|---|---|
| `worker/src/types/crew.rs` | Pole `arrival_buffer_percent` a `arrival_buffer_fixed_minutes` ze struct `Crew`, `CreateCrewRequest`, `UpdateCrewRequest` + testy |
| `worker/src/db/queries/crew.rs` | Sloupce z INSERT/UPDATE/SELECT dotazÅ¯ |
| `worker/migrations/001_initial_schema.sql` | Odebrat sloupce z `crews` tabulky |
| `worker/migrations/004_add_crew_buffer.sql` | Smazat celÃ½ soubor |
| `worker/migrations/005_fix_crew_buffer_type.sql` | Smazat celÃ½ soubor |
| `worker/migrations/014_add_crew_fixed_buffer.sql` | Smazat celÃ½ soubor |
| `apps/web/src/services/crewService.ts` | Pole z `Crew`, `CreateCrewRequest`, `UpdateCrewRequest` |
| `apps/web/src/pages/Settings.tsx` | Odebrat buffer inputy z `CrewForm` + `CrewFormData` + create/update volÃ¡nÃ­ |
| `apps/web/public/locales/{cs,en,sk}/settings.json` | KlÃ­Äe `crew_arrival_buffer_*` (4 klÃ­Äe Ã— 3 jazyky) |

### 2.2 PÅ™idÃ¡nÃ­ na trasu (route)

| Soubor | Co pÅ™idat |
|---|---|
| `worker/migrations/001_initial_schema.sql` | Sloupce `arrival_buffer_percent` a `arrival_buffer_fixed_minutes` do `routes` tabulky |
| `worker/src/types/route.rs` | Pole do struct `Route` |
| `worker/src/db/queries/route.rs` | Sloupce do `upsert_route` (INSERT + UPDATE + SELECT) |
| `worker/src/handlers/route.rs` | Pole do `SaveRouteRequest`, `RecalculateRequest` Äte buffer z payloadu (beze zmÄ›ny â€” uÅ¾ to dÄ›lÃ¡) |
| `worker/src/handlers/jobs.rs` | ÄŒtenÃ­ bufferu z trasy mÃ­sto z posÃ¡dky |
| `packages/shared-types/src/route.ts` | Pole do `Route` interface |
| `apps/web/src/services/routeService.ts` | Pole do `SaveRouteRequest`, `SavedRoute` |

### 2.3 UÅ¾ivatelskÃ© preference (last-used default)

| Soubor | Co pÅ™idat |
|---|---|
| `worker/migrations/001_initial_schema.sql` | Sloupce `last_arrival_buffer_percent` a `last_arrival_buffer_fixed_minutes` do `users` tabulky |
| `worker/src/types/settings.rs` | Pole do `UserPreferences` |
| `worker/src/db/queries/settings.rs` | ÄŒtenÃ­ a zÃ¡pis novÃ½ch preferencÃ­ |
| `worker/src/handlers/route.rs` | Po uloÅ¾enÃ­ trasy aktualizovat uÅ¾ivatelskÃ© preference |
| `packages/shared-types/src/settings.ts` | Pole do `UserPreferences` |
| `apps/web/src/services/settingsService.ts` | Pole do `UserPreferences` |

### 2.4 Frontend â€” zobrazenÃ­ a editace na timeline

| Soubor | Co pÅ™idat |
|---|---|
| `apps/web/src/components/planner/RouteDetailTimeline.tsx` | NovÃ½ props, zobrazenÃ­ drobnÃ½m pÃ­smem, inline editor |
| `apps/web/src/components/planner/RouteDetailTimeline.module.css` | Styly pro buffer info + editor |
| `apps/web/src/pages/PlanningInbox.tsx` | PÅ™edÃ¡nÃ­ buffer props do timeline, handler pro zmÄ›nu, pÅ™eÄtenÃ­ defaultu z preferences |
| `apps/web/public/locales/{cs,en,sk}/planner.json` | PÅ™eklady pro buffer label, editor |

---

## 3. DatovÃ½ model

### 3.1 Tabulka `routes` â€” novÃ© sloupce

```sql
arrival_buffer_percent         DOUBLE PRECISION NOT NULL DEFAULT 10.0,
arrival_buffer_fixed_minutes   DOUBLE PRECISION NOT NULL DEFAULT 0.0
```

### 3.2 Tabulka `users` â€” novÃ© sloupce (preference)

```sql
last_arrival_buffer_percent         DOUBLE PRECISION NOT NULL DEFAULT 10.0,
last_arrival_buffer_fixed_minutes   DOUBLE PRECISION NOT NULL DEFAULT 0.0
```

### 3.3 Tabulka `crews` â€” odebranÃ© sloupce

```
arrival_buffer_percent         -- ODEBRAT
arrival_buffer_fixed_minutes   -- ODEBRAT
```

### 3.4 Rust structs

```rust
// Route â€” pÅ™idat pole:
pub struct Route {
    // ... existujÃ­cÃ­ ...
    pub arrival_buffer_percent: f64,
    pub arrival_buffer_fixed_minutes: f64,
}

// SaveRouteRequest â€” pÅ™idat pole:
pub struct SaveRouteRequest {
    // ... existujÃ­cÃ­ ...
    pub arrival_buffer_percent: f64,
    pub arrival_buffer_fixed_minutes: f64,
}

// UserPreferences â€” pÅ™idat pole:
pub struct UserPreferences {
    // ... existujÃ­cÃ­ ...
    pub last_arrival_buffer_percent: f64,
    pub last_arrival_buffer_fixed_minutes: f64,
}
```

### 3.5 TypeScript types

```typescript
// Route â€” pÅ™idat pole:
export interface Route {
  // ... existujÃ­cÃ­ ...
  arrivalBufferPercent: number;
  arrivalBufferFixedMinutes: number;
}

// SaveRouteRequest â€” pÅ™idat pole:
export interface SaveRouteRequest {
  // ... existujÃ­cÃ­ ...
  arrivalBufferPercent: number;
  arrivalBufferFixedMinutes: number;
}

// SavedRoute â€” pÅ™idat pole:
export interface SavedRoute {
  // ... existujÃ­cÃ­ ...
  arrivalBufferPercent: number;
  arrivalBufferFixedMinutes: number;
}

// UserPreferences â€” pÅ™idat pole:
export interface UserPreferences {
  // ... existujÃ­cÃ­ ...
  lastArrivalBufferPercent: number;
  lastArrivalBufferFixedMinutes: number;
}
```

---

## 4. ChovÃ¡nÃ­

### 4.1 VytvoÅ™enÃ­ novÃ© trasy

1. Frontend naÄte `settings.preferences.lastArrivalBufferPercent` a `lastArrivalBufferFixedMinutes`.
2. Tyto hodnoty se drÅ¾Ã­ v lokÃ¡lnÃ­m stavu `PlanningInbox` (state `routeBufferPercent`, `routeBufferFixedMinutes`).
3. PÅ™i kaÅ¾dÃ©m `recalculateRoute()` se poÅ¡lou jako `arrivalBufferPercent` / `arrivalBufferFixedMinutes`.
4. PÅ™i kaÅ¾dÃ©m `saveRoute()` se poÅ¡lou v `SaveRouteRequest`.
5. Backend `handle_save_route` uloÅ¾Ã­ buffer do `routes` tabulky.
6. Backend po ÃºspÄ›Å¡nÃ©m uloÅ¾enÃ­ aktualizuje `users.last_arrival_buffer_percent` a `users.last_arrival_buffer_fixed_minutes`.

### 4.2 NaÄtenÃ­ existujÃ­cÃ­ trasy

1. `getRoute()` vracÃ­ `SavedRoute` s `arrivalBufferPercent` a `arrivalBufferFixedMinutes`.
2. Frontend z tÄ›chto hodnot inicializuje lokÃ¡lnÃ­ stav.

### 4.3 Editace bufferu na timeline

1. Pod hlaviÄkou timeline (pod depot departure) je drobnÃ½ text: â€Rezerva: 10 % + 0 min".
2. Po kliknutÃ­ se text zmÄ›nÃ­ na inline editor (dva malÃ© inputy: `%` a `min`).
3. Po potvrzenÃ­ (Enter / blur) se:
   a. Aktualizuje lokÃ¡lnÃ­ stav.
   b. SpustÃ­ `recalculateRoute()` s novÃ½mi hodnotami.
   c. Autosave uloÅ¾Ã­ trasu (vÄetnÄ› novÃ©ho bufferu).

### 4.4 Route planning job (async)

`handle_route_plan_job` v `handlers/jobs.rs` dnes Äte buffer z posÃ¡dky. NovÄ›:

1. PÅ™ijme buffer jako parametr v `RoutePlanJobRequest`.
2. Frontend buffer pÅ™edÃ¡ pÅ™i submitu jobu.
3. AlternativnÄ›: job naÄte buffer z existujÃ­cÃ­ trasy v DB (pokud trasa uÅ¾ existuje).

---

## 5. UI mockup (RouteDetailTimeline)

```
ğŸ“ Sklad Brno                              â† depot card
   Odjezd: 07:24
   â”€â”€â”€ Rezerva: 10 % + 0 min âœï¸ â”€â”€â”€        â† novÃ½ Å™Ã¡dek, drobnÃ© pÃ­smo
   â–¼ 12.3 km â€¢ 18 min
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ 1. NovÃ¡k s.r.o.                â”‚      â† stop card
   â”‚    PÅ™Ã­jezd: 07:42 â†’ Odjezd: ... â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â–¼ 8.1 km â€¢ 12 min
   ...
```

Po kliknutÃ­ na âœï¸:

```
   â”€â”€â”€ Rezerva: [10] % + [0] min  âœ“ âœ• â”€â”€â”€ â† inline edit
```

---

## 6. ImplementaÄnÃ­ plÃ¡n (TDD)

DatabÃ¡zi nemigrujeme â€” bude vytvoÅ™ena znovu. UpravÃ­me pÅ™Ã­mo `001_initial_schema.sql` a smaÅ¾eme starÃ© buffer migrace.

KaÅ¾dÃ½ krok se Å™Ã­dÃ­ cyklem RED â†’ GREEN â†’ REFACTOR:
1. Napsat failing test (RED)
2. Napsat minimÃ¡lnÃ­ implementaci, aby test proÅ¡el (GREEN)
3. Refaktorovat pokud potÅ™eba (REFACTOR)
4. OdÅ¡krtnout krok v tomto souboru

### FÃ¡ze 1: DatabÃ¡ze a migrace (scaffold)

- [x] **1.1** V `001_initial_schema.sql` pÅ™idat do tabulky `routes`:
  - `arrival_buffer_percent DOUBLE PRECISION NOT NULL DEFAULT 10.0`
  - `arrival_buffer_fixed_minutes DOUBLE PRECISION NOT NULL DEFAULT 0.0`
- [x] **1.2** V `001_initial_schema.sql` pÅ™idat do tabulky `users`:
  - `last_arrival_buffer_percent DOUBLE PRECISION NOT NULL DEFAULT 10.0`
  - `last_arrival_buffer_fixed_minutes DOUBLE PRECISION NOT NULL DEFAULT 0.0`
- [x] **1.3** V `001_initial_schema.sql` odebrat z tabulky `crews`: nebyly v base schema (pÅ™idÃ¡ny migracÃ­) âœ…
- [x] **1.4** Smazat migrace: `004_add_crew_buffer.sql`, `005_fix_crew_buffer_type.sql`, `014_add_crew_fixed_buffer.sql` âœ…

### FÃ¡ze 2: Rust typy â€” crew (odebrat buffer) + testy

- [x] **2.1** TEST: `test_crew_no_buffer_fields` â€” `CreateCrewRequest` bez `arrivalBufferPercent` se deserializuje OK; serializovanÃ½ `Crew` neobsahuje klÃ­Ä `arrivalBufferPercent`. âœ…
  - GREEN: OdebrÃ¡no ze struct `Crew`, `CreateCrewRequest`, `UpdateCrewRequest`. Testy pÅ™epsÃ¡ny.
- [x] **2.2** `db/queries/crew.rs` â€” odebrÃ¡ny buffer sloupce z INSERT, UPDATE, SELECT dotazÅ¯ âœ…
- [x] **2.3** `cargo check` â€” handlers doÄasnÄ› defaultujÃ­ buffer na 10.0/0.0 (TODO pro fÃ¡zi 6) âœ…

### FÃ¡ze 3: Rust typy â€” route (pÅ™idat buffer) + TDD

- [x] **3.1** TEST: `test_route_serializes_buffer_fields` â€” Route serializuje `arrivalBufferPercent` a `arrivalBufferFixedMinutes` âœ…
  - GREEN: PÅ™idÃ¡na pole do `types/route.rs` â†’ struct `Route`.
- [x] **3.2** TEST: `test_save_route_request_deserializes_buffer` â€” SaveRouteRequest deserializuje buffer z JSON âœ…
  - GREEN: PÅ™idÃ¡na pole do `SaveRouteRequest` v `handlers/route.rs`.
- [x] **3.3** TEST: `test_save_route_request_buffer_defaults` â€” bez buffer polÃ­ defaultuje na 10.0 / 0.0 âœ…
  - GREEN: `#[serde(default = "default_buffer_percent")]` a `#[serde(default)]`.
- [x] **3.4** `cargo check` âœ…

### FÃ¡ze 4: Rust typy â€” user preferences (pÅ™idat last-used buffer) + TDD

- [x] **4.1** TEST: `test_user_preferences_has_last_buffer` â€” serializace/deserializace buffer polÃ­ v `UserPreferences` âœ…
  - GREEN: PÅ™idÃ¡na pole do `UserPreferences`, `UserWithSettings`, `to_preferences()`.
- [x] **4.2** `cargo check` âœ…

### FÃ¡ze 5: DB dotazy â€” route upsert + TDD

- [x] **5.1** `upsert_route` â€” pÅ™idÃ¡ny `arrival_buffer_percent` a `arrival_buffer_fixed_minutes` do INSERT, UPDATE, RETURNING + parametry funkce âœ…
- [x] **5.2** `get_route_for_date`, `get_route_by_id`, `RouteWithCrewInfo`, `list_routes*` â€” pÅ™idÃ¡ny buffer sloupce do SELECT âœ…
- [x] **5.3** `db/queries/settings.rs` â€” pÅ™idÃ¡no ÄtenÃ­ buffer z `get_user_settings`, novÃ¡ funkce `update_last_arrival_buffer` âœ…
- [x] **5.4** `cargo check` âœ…

### FÃ¡ze 6: Handlery â€” save route uklÃ¡dÃ¡ buffer a aktualizuje preferences + TDD

- [x] **6.1** `SaveRouteRequest` buffer pole fungujÃ­ (ovÄ›Å™eno v fÃ¡zi 3) âœ…
- [x] **6.2** `handle_save_route` â€” pÅ™edÃ¡vÃ¡ buffer do `upsert_route`, po uloÅ¾enÃ­ volÃ¡ `update_last_arrival_buffer` âœ…
- [x] **6.3** `handle_get_route` â€” buffer pole v response automaticky dÃ­ky fÃ¡zi 5 âœ…
- [x] **6.4** `handle_recalculate` â€” beze zmÄ›ny âœ…
- [x] **6.5** `RoutePlanJobRequest` â€” pÅ™idÃ¡na `arrival_buffer_percent` a `arrival_buffer_fixed_minutes` s serde defaults âœ…
- [x] **6.6** `RoutePlanRequest` â€” pÅ™idÃ¡na buffer pole, handler Äte z requestu mÃ­sto crew âœ…
- [x] **6.7** `handlers/jobs.rs` â€” Äte buffer z `request.arrival_buffer_percent` mÃ­sto crew âœ…
- [x] **6.8** `cargo check` âœ…
- [x] **6.9** `cargo test` â€” 282 passed, 0 failed âœ…

### FÃ¡ze 7: TypeScript shared types

- [x] **7.1** `packages/shared-types/src/route.ts` â€” pÅ™idÃ¡no `arrivalBufferPercent` a `arrivalBufferFixedMinutes` do `Route` âœ…
- [x] **7.2** `packages/shared-types/src/settings.ts` â€” pÅ™idÃ¡no `lastArrivalBufferPercent` a `lastArrivalBufferFixedMinutes` do `UserPreferences` âœ…

### FÃ¡ze 8: Frontend services

- [x] **8.1** `routeService.ts` â€” pÅ™idÃ¡no `arrivalBufferPercent` a `arrivalBufferFixedMinutes` do `SaveRouteRequest`, `SavedRoute`, `RoutePlanJobRequest` âœ…
- [x] **8.2** `crewService.ts` â€” odebrÃ¡no `arrivalBufferPercent` a `arrivalBufferFixedMinutes` z `Crew`, `CreateCrewRequest`, `UpdateCrewRequest` âœ…
- [x] **8.3** `settingsService.ts` â€” pÅ™idÃ¡no `lastArrivalBufferPercent` a `lastArrivalBufferFixedMinutes` do `UserPreferences` âœ…
- [ ] **8.4** `tsc --noEmit` â€” oÄekÃ¡vÃ¡me chyby v PlanningInbox a Settings (opravÃ­me v dalÅ¡Ã­ch fÃ¡zÃ­ch)

### FÃ¡ze 9: Frontend â€” PlanningInbox (buffer state + flow)

- [x] **9.1** PÅ™idÃ¡n lokÃ¡lnÃ­ stav `routeBufferPercent` a `routeBufferFixedMinutes`, init z preferences, override ze savedRoute âœ…
- [x] **9.2** `triggerRecalculate` â€” Äte z `routeBufferPercent` / `routeBufferFixedMinutes` mÃ­sto crew âœ…
- [x] **9.3** `autoSaveFn` â€” pÅ™edÃ¡vÃ¡ buffer v `SaveRouteRequest` âœ…
- [x] **9.4** `handleBufferChange` handler â†’ update stavu â†’ `triggerRecalculate()` âœ…
- [x] **9.5** Buffer props + `onBufferChange` pÅ™edÃ¡ny do `RouteDetailTimeline`, buffer do `submitRoutePlanJob` âœ…
- [ ] **9.6** `tsc --noEmit` â€” ovÄ›Å™it kompilaci.

### FÃ¡ze 10: Frontend â€” RouteDetailTimeline (zobrazenÃ­ a editace)

- [x] **10.1** Props `arrivalBufferPercent`, `arrivalBufferFixedMinutes`, `onBufferChange` pÅ™idÃ¡ny âœ…
- [x] **10.2** Buffer info zobrazeno drobnÃ½m pÃ­smem pod depot, kliknutÃ­m se rozbalÃ­ editor âœ…
- [x] **10.3** Inline editor: dva number inputy, UloÅ¾it/ZruÅ¡it tlaÄÃ­tka âœ…
- [x] **10.4** CSS styly `.bufferBar`, `.bufferEdit`, `.bufferEditRow`, `.bufferEditActions` âœ…
- [x] **10.5** `tsc --noEmit` â€” ovÄ›Å™eno ve fÃ¡zi 13 âœ…

### FÃ¡ze 11: Frontend â€” Settings crew form (odebrat buffer)

- [x] **11.1** `Settings.tsx` â€” odebrÃ¡no buffer z `CrewFormData`, `createCrew`, `updateCrew`, crew list display, form inputs âœ…
- [x] **11.2** OdebrÃ¡ny pÅ™eklad. klÃ­Äe `crew_arrival_buffer_*` a `crew_buffer` z `{cs,en,sk}/settings.json` âœ…
- [ ] **11.3** `tsc --noEmit`

### FÃ¡ze 12: Frontend â€” pÅ™eklady (novÃ© klÃ­Äe)

- [x] **12.1** PÅ™idÃ¡ny pÅ™eklady `buffer_info`, `buffer_percent_label`, `buffer_fixed_label`, `buffer_save`, `buffer_cancel` do `{cs,en,sk}/planner.json` âœ…
- [x] **12.2** OdebrÃ¡ny starÃ© crew buffer klÃ­Äe z `{cs,en,sk}/settings.json` âœ…

### FÃ¡ze 13: FinÃ¡lnÃ­ ovÄ›Å™enÃ­

- [x] **13.1** `cargo check` â€” backend kompiluje bez chyb âœ…
- [x] **13.2** `cargo test` â€” 282 passed, 0 failed âœ…
- [x] **13.3** `tsc` â€” opraven test `RouteListPanel.test.tsx` (chybÄ›jÃ­cÃ­ povinnÃ¡ pole v `SavedRoute`). OstatnÃ­ chyby jsou pre-existujÃ­cÃ­ (unused imports) âœ…
- [ ] **13.4** ManuÃ¡lnÃ­ QA:
  - VytvoÅ™it novou trasu â†’ buffer se pÅ™edvyplnÃ­ z user preferences (10 % + 0 min).
  - OvÄ›Å™it zobrazenÃ­ bufferu na timeline drobnÃ½m pÃ­smem.
  - Kliknout na buffer â†’ editovat â†’ potvrdit â†’ ovÄ›Å™it pÅ™epoÄet ETA.
  - UloÅ¾it trasu â†’ buffer se uloÅ¾Ã­ do DB.
  - VytvoÅ™it druhou trasu â†’ ovÄ›Å™it, Å¾e se pÅ™edvyplnÃ­ poslednÄ› pouÅ¾itÃ¡ hodnota.
  - OtevÅ™Ã­t nastavenÃ­ posÃ¡dky â†’ buffer tam uÅ¾ nenÃ­.

---

## 8. Inline editace timeline + sdÃ­lenÃ½ ArrivalBufferBar

### 8.1 Motivace

Po pÅ™esunu bufferu na trasu pÅ™ichÃ¡zÃ­ dalÅ¡Ã­ krok: umoÅ¾nit dispeÄerovi **pÅ™Ã­mo v timeline** ruÄnÄ› upravit trvÃ¡nÃ­ libovolnÃ© poloÅ¾ky â€” zastÃ¡vky (servis), Ãºseky cesty a pauzy. Jde o Å™eÅ¡enÃ­ mimoÅ™Ã¡dnÃ½ch situacÃ­ (zÃ¡cpa, prodlouÅ¾enÃ½ servis). Tyto overridem â€natvrdo" nastavenÃ© hodnoty pÅ™epÃ­Å¡Ã­ vypoÄÃ­tanÃ©/dohodnutÃ© a uloÅ¾Ã­ se do DB.

SouÄasnÄ› se `ArrivalBufferBar` stane sdÃ­lenou komponentou pouÅ¾itou v `PlanningInbox` i `Planner`.

### 8.2 ChovÃ¡nÃ­

1. **KaÅ¾dÃ¡ poloÅ¾ka timeline** (zastÃ¡vka, Ãºsek cesty, pauza) bude mÃ­t v pravÃ© ÄÃ¡sti **editovatelnÃ½ Ãºdaj trvÃ¡nÃ­**.
2. Po ruÄnÃ­m pÅ™epsÃ¡nÃ­ hodnoty se pole vizuÃ¡lnÄ› odliÅ¡Ã­: **vÃ½straÅ¾nÃ¡ ikona âš ï¸** + tooltip â€RuÄnÄ› upraveno".
3. KliknutÃ­m na ikonu âš ï¸ se hodnota **vrÃ¡tÃ­ na pÅ¯vodnÃ­** (vypoÄÃ­tanou / dohodnutou).
4. **PÅ™epoÄet shora dolÅ¯**: zmÄ›na na pozici N pÅ™epoÄÃ­tÃ¡ Äasy od pozice N+1 dolÅ¯. UdÃ¡losti pÅ™ed N se nemÄ›nÃ­. Pokud buffery po trase absorbujÃ­ rozdÃ­l, pÅ™epoÄet se neprojevÃ­.
5. **Drag & drop reorder** zastÃ¡vek â€” uÅ¾ funguje (DnD kit), zachovÃ¡me.
6. ChovÃ¡nÃ­ je identickÃ© v `PlanningInbox` i `Planner`.

### 8.3 DatovÃ½ model â€” override sloupce v `route_stops`

```sql
-- PÅ™idat do tabulky route_stops v 001_initial_schema.sql:
override_service_duration_minutes  INTEGER,   -- NULL = pouÅ¾ij vypoÄÃ­tanou, non-NULL = manuÃ¡lnÃ­ override
override_travel_duration_minutes   INTEGER,   -- NULL = pouÅ¾ij Valhalla Äas, non-NULL = manuÃ¡lnÃ­ override
```

Logika:
- `effectiveServiceDuration = override_service_duration_minutes ?? service_duration_minutes ?? default`
- `effectiveTravelDuration = override_travel_duration_minutes ?? duration_from_previous_minutes`
- VzdÃ¡lenost (`distance_from_previous_km`) se overridem nemÄ›nÃ­.

### 8.4 Rust structs â€” rozÅ¡Ã­Å™enÃ­

```rust
// RouteStop (existujÃ­cÃ­) â€” pÅ™idat:
pub override_service_duration_minutes: Option<i32>,
pub override_travel_duration_minutes: Option<i32>,
```

### 8.5 TypeScript types â€” rozÅ¡Ã­Å™enÃ­

```typescript
// SavedRouteStop â€” pÅ™idat:
overrideServiceDurationMinutes?: number | null;
overrideTravelDurationMinutes?: number | null;
```

### 8.6 RecalcStopInput â€” rozÅ¡Ã­Å™enÃ­

```typescript
// PÅ™idat do RecalcStopInput:
overrideServiceDurationMinutes?: number | null;
overrideTravelDurationMinutes?: number | null;
```

Backend `handle_recalculate`:
- Pokud `overrideTravelDurationMinutes` je nastaveno, pouÅ¾ije ho mÃ­sto Valhalla doby jÃ­zdy.
- Pokud `overrideServiceDurationMinutes` je nastaveno, pouÅ¾ije ho mÃ­sto defaultu/scheduled.

### 8.7 UI mockup â€” inline editace

```
ğŸ“ Depo D1                                   07:30
   Rezerva pÅ™Ã­jezdu: 10 % + 0 min            â† ArrivalBufferBar
   â–¼ 45.5 km â€¢ [41 min] âš ï¸                   â† editovatelnÃ½ Ãºsek cesty, override indikÃ¡tor
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ 1  KomÃ­nServis trade k.s.  08:41â€“09:11 â”‚
   â”‚    [30 min] âš ï¸                         â”‚ â† editovatelnÃ¡ doba servisu
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â–¼ 12.3 km â€¢ 18 min                        â† normÃ¡lnÃ­ (bez override)
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ 2  Radek ÄŒernÃ½           09:29â€“09:59 â”‚
   â”‚    30 min                              â”‚ â† normÃ¡lnÃ­
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- `[41 min]` â€” inline input (number), editovatelnÃ½ kliknutÃ­m.
- `âš ï¸` â€” indikÃ¡tor override. Klik â†’ reset na vypoÄÃ­tanou hodnotu.
- Pole bez override se zobrazujÃ­ normÃ¡lnÄ› (bez ikony).

---

## 9. ImplementaÄnÃ­ plÃ¡n â€” Inline editace timeline (TDD)

DatabÃ¡zi nemigrujeme â€” bude vytvoÅ™ena znovu (`001_initial_schema.sql`).

KaÅ¾dÃ½ krok se Å™Ã­dÃ­ cyklem RED â†’ GREEN â†’ REFACTOR.

### ğŸ“Š Stav implementace (2026-02-17)

| FÃ¡ze | Popis | Stav |
|------|-------|------|
| A | SdÃ­lenÃ¡ `ArrivalBufferBar` + Planner integrace | âœ… Hotovo, commitnuto & pushnuto |
| B | DB schÃ©ma â€” override sloupce v `route_stops` | âœ… Hotovo, commitnuto & pushnuto |
| C | Rust typy â€” override pole + TDD testy | âœ… Hotovo, commitnuto & pushnuto |
| D | DB dotazy â€” SELECT/INSERT s overrides | âœ… Hotovo, commitnuto & pushnuto |
| E | Backend recalculate â€” respektovat overrides | âœ… Hotovo, commitnuto & pushnuto |
| F | Frontend shared types â€” override pole | âœ… Hotovo, commitnuto & pushnuto |
| G | Inline editace Ãºseku cesty (travel duration) | âœ… Hotovo, commitnuto & pushnuto |
| H | Inline editace zastÃ¡vky (service duration) | âœ… Hotovo, commitnuto & pushnuto |
| I | Handlery v PlanningInbox + Planner | âœ… Hotovo, commitnuto & pushnuto |
| J | PÅ™eklady | âœ… Hotovo, commitnuto & pushnuto |
| K | FinÃ¡lnÃ­ ovÄ›Å™enÃ­ | âœ… Hotovo, commitnuto & pushnuto |

**Commity:**
- `6b259d6` â€” phase A: extract shared ArrivalBufferBar, integrate into Planner
- `e749984` â€” phase B: add override columns to route_stops schema
- `cb7bfd9` â€” phase C: add override fields to Rust types with TDD tests

- `48b2d80` â€” phase D: add override fields to DB queries (SELECT/INSERT)

### FÃ¡ze A: SdÃ­lenÃ¡ komponenta ArrivalBufferBar

- [x] **A.1** PÅ™esunout `ArrivalBufferBar` z `PlanningInbox.tsx` do `apps/web/src/components/planner/ArrivalBufferBar.tsx` jako exportovanou komponentu.
- [x] **A.2** CSS styly `.bufferBar`, `.bufferBarExpanded`, `.bufferEditRow`, `.bufferEditActions`, `.bufferLabel` pÅ™esunout do `ArrivalBufferBar.module.css`.
- [x] **A.3** V `PlanningInbox.tsx` importovat `ArrivalBufferBar` ze sdÃ­lenÃ© komponenty, odebrat lokÃ¡lnÃ­ definici a CSS.
- [x] **A.4** V `Planner.tsx` pÅ™idat buffer state (`routeBufferPercent`, `routeBufferFixedMinutes`), inicializaci z user preferences, `handleBufferChange` handler.
- [x] **A.5** V `Planner.tsx` vloÅ¾it `<ArrivalBufferBar>` mezi akce a timeline (stejnÃ¡ pozice jako v PlanningInbox).
- [x] **A.6** Exportovat `ArrivalBufferBar` z `components/planner/index.ts`.
- [x] **A.7** OvÄ›Å™it zobrazenÃ­ v obou pohledech (`PlanningInbox` + `Planner`).

### FÃ¡ze B: DB schÃ©ma â€” override sloupce

- [x] **B.1** V `001_initial_schema.sql` pÅ™idat do `route_stops`:
  - `override_service_duration_minutes INTEGER` (nullable)
  - `override_travel_duration_minutes INTEGER` (nullable)
- [x] **B.2** OvÄ›Å™it, Å¾e schema je validnÃ­ (`psql -f`).

### FÃ¡ze C: Rust typy â€” route stop overrides + TDD

- [x] **C.1** RED: Test `test_route_stop_override_fields_serialize` â€” struct s `override_service_duration_minutes: Some(45)` se serializuje s klÃ­Äem `overrideServiceDurationMinutes`.
  - GREEN: PÅ™idat `override_service_duration_minutes: Option<i32>` a `override_travel_duration_minutes: Option<i32>` do struct v `types/route.rs` (nebo pÅ™Ã­sluÅ¡nÃ½ stop struct).
- [x] **C.2** RED: Test `test_route_stop_override_null_skipped` â€” struct s `None` neobsahuje klÃ­Ä v JSON (skip_serializing_if).
  - GREEN: `#[serde(skip_serializing_if = "Option::is_none")]`.
- [x] **C.3** `cargo check` â€” ovÄ›Å™it kompilaci.

### FÃ¡ze D: DB dotazy â€” route stops s overrides + TDD

- [x] **D.1** PÅ™idat `override_service_duration_minutes` a `override_travel_duration_minutes` do SELECT dotazÅ¯ v `db/queries/route.rs` (vÅ¡echny funkce vracejÃ­cÃ­ route stops).
- [x] **D.2** PÅ™idat override pole do INSERT/UPDATE dotazu pro route stops (v `upsert_route` nebo `save_route_stops`).
- [x] **D.3** `cargo check` â€” nelze ovÄ›Å™it bez Docker/DB (pre-existujÃ­cÃ­ `sqlx::query_scalar!` v `import.rs`). Moje zmÄ›ny pouÅ¾Ã­vajÃ­ `sqlx::query_as` (runtime) â€” syntakticky ovÄ›Å™eno, probÄ›hne pÅ™i spuÅ¡tÄ›nÃ­ DB.

### FÃ¡ze E: Backend recalculate â€” respektovat overrides

- [x] **E.1** RED: Test `override_travel_duration_replaces_matrix` â€” vstup s `override_travel_duration_minutes: Some(60)` vrÃ¡tÃ­ ETA liÅ¡Ã­cÃ­ se od Valhalla vÃ½poÄtu.
  - GREEN: V `sequential_schedule.rs`: pokud stop mÃ¡ `override_travel_duration_minutes`, pouÅ¾Ã­t mÃ­sto matice.
- [x] **E.2** RED: Test `override_service_duration_replaces_calculated` â€” vstup s `override_service_duration_minutes: Some(45)` vrÃ¡tÃ­ departure = arrival + 45 min.
  - GREEN: V scheduling logice: pokud stop mÃ¡ `override_service_duration_minutes`, pouÅ¾Ã­t mÃ­sto default/scheduled.
- [x] **E.3** `cargo test` â€” 20/20 testÅ¯ proÅ¡lo (vÄetnÄ› `both_overrides_together`).

### FÃ¡ze F: Frontend shared types â€” override pole

- [x] **F.1** `packages/shared-types/src/route.ts` â€” pÅ™idÃ¡no do `RouteStop` a `PlannedRouteStop`.
- [x] **F.2** `apps/web/src/services/routeService.ts` â€” pÅ™idÃ¡no do `SavedRouteStop`, `SaveRouteStop`, `RecalcStopInput`.

### FÃ¡ze G: Frontend â€” inline editace Ãºseku cesty (travel duration)

- [x] **G.1** `RouteDetailTimeline.tsx` â€” segment zobrazÃ­ dobu jÃ­zdy jako `<input type="number">` (inline). Po zmÄ›nÄ› volÃ¡ `onUpdateTravelDuration(stopId, minutes)`.
- [x] **G.2** Pokud `overrideTravelDurationMinutes != null`, zobrazit vedle inputu ikonu âš ï¸. Klik â†’ reset (`onResetTravelDuration(stopId)`).
- [x] **G.3** CSS styly pro inline input v segmentu + override indikÃ¡tor.
- [x] **G.4** `PlanningTimeline.tsx` â€” stejnÃ¡ logika (travel segment editace).
- [x] **G.5** Props pÅ™idÃ¡ny do obou timeline komponent. `buildTimelineItems.ts` â€” travel items nynÃ­ obsahujÃ­ `stop` referenci.

### FÃ¡ze H: Frontend â€” inline editace zastÃ¡vky (service duration)

- [x] **H.1** `RouteDetailTimeline.tsx` â€” zastÃ¡vka zobrazÃ­ dobu servisu jako `<input type="number">` (inline). Po zmÄ›nÄ› volÃ¡ `onUpdateServiceDuration(stopId, minutes)`.
- [x] **H.2** Pokud `overrideServiceDurationMinutes != null`, zobrazit vedle inputu ikonu âš ï¸. Klik â†’ reset (`onResetServiceDuration(stopId)`).
- [x] **H.3** CSS styly pro inline input u zastÃ¡vky + override indikÃ¡tor.
- [x] **H.4** `PlanningTimeline.tsx` â€” stejnÃ¡ logika (SortableStopCard).
- [x] **H.5** Props pÅ™idÃ¡ny do obou timeline komponent.

### FÃ¡ze I: Frontend â€” handlery v PlanningInbox + Planner

- [x] **I.1** `PlanningInbox.tsx` â€” 4 handlery implementovÃ¡ny (`handleUpdateTravelDuration`, `handleResetTravelDuration`, `handleUpdateServiceDuration`, `handleResetServiceDuration`), kaÅ¾dÃ½ spouÅ¡tÃ­ `triggerRecalculate`.
- [x] **I.2** VÅ¡echny 4 handlery pÅ™edÃ¡ny jako props do obou timeline komponent.
- [x] **I.3** `triggerRecalculate` â€” override pole zahrnuta v `RecalcStopInput[]`.
- [x] **I.4** `autoSaveFn` â€” override pole zahrnuta v `SaveRouteRequest`.
- [x] **I.5** `Planner.tsx` â€” totoÅ¾nÃ© handlery implementovÃ¡ny (local state only, Planner nemÃ¡ recalculate).
- [x] **I.6** DnD reorder zachovÃ¡vÃ¡ override hodnoty (spread operator na stop objektech).

### FÃ¡ze J: Frontend â€” pÅ™eklady

- [x] **J.1** `{cs,en,sk}/planner.json` â€” pÅ™idÃ¡ny klÃ­Äe `service_duration_label` a `override_reset_tooltip`.

### FÃ¡ze K: FinÃ¡lnÃ­ ovÄ›Å™enÃ­

- [x] **K.1** `cargo check` â€” nelze bez Docker DB (pre-existujÃ­cÃ­ `sqlx::query_scalar!`), ale moje zmÄ›ny pouÅ¾Ã­vajÃ­ `sqlx::query_as` (runtime).
- [x] **K.2** `cargo test` â€” 22/22 testÅ¯ proÅ¡lo (20 sequential_schedule + 2 route type).
- [x] **K.3** `tsc --noEmit` â€” Å¾Ã¡dnÃ© novÃ© chyby z inline-edit feature (pre-existujÃ­cÃ­ chyby nezmÄ›nÄ›ny).
- [ ] **K.4** ManuÃ¡lnÃ­ QA (vyÅ¾aduje spuÅ¡tÄ›nÃ­ Docker + app stack):
  - VytvoÅ™it trasu se 3+ zastÃ¡vkami.
  - Kliknout na dobu jÃ­zdy v segmentu â†’ zmÄ›nit na vyÅ¡Å¡Ã­ hodnotu â†’ ovÄ›Å™it pÅ™epoÄet ETA shora dolÅ¯.
  - OvÄ›Å™it âš ï¸ ikonu u overridnutÃ©ho segmentu.
  - Kliknout na âš ï¸ â†’ ovÄ›Å™it reset na pÅ¯vodnÃ­ hodnotu.
  - Kliknout na dobu servisu u zastÃ¡vky â†’ zmÄ›nit â†’ ovÄ›Å™it pÅ™epoÄet.
  - UloÅ¾it trasu â†’ reload â†’ ovÄ›Å™it, Å¾e overrides pÅ™etrvajÃ­.
  - OvÄ›Å™it identickÃ© chovÃ¡nÃ­ v Planner.
  - OvÄ›Å™it ArrivalBufferBar v Planner.
  - DnD reorder zastÃ¡vky s override â†’ override se zachovÃ¡.

---

## 10. Soubory dotÄenÃ© zmÄ›nami (inline editace)

### NovÃ© soubory
- `apps/web/src/components/planner/ArrivalBufferBar.tsx` â€” sdÃ­lenÃ¡ komponenta
- `apps/web/src/components/planner/ArrivalBufferBar.module.css` â€” styly

### ZmÄ›nÄ›nÃ© soubory â€” backend
- `worker/migrations/001_initial_schema.sql` â€” override sloupce v `route_stops`
- `worker/src/types/route.rs` â€” override pole ve struct
- `worker/src/db/queries/route.rs` â€” override v SELECT/INSERT/UPDATE
- `worker/src/handlers/route.rs` â€” override v recalculate/save
- `worker/src/services/sequential_schedule.rs` â€” respektovat overrides pÅ™i scheduling

### ZmÄ›nÄ›nÃ© soubory â€” shared types
- `packages/shared-types/src/route.ts` â€” override pole

### ZmÄ›nÄ›nÃ© soubory â€” frontend
- `apps/web/src/services/routeService.ts` â€” override v `SavedRouteStop`, `RecalcStopInput`
- `apps/web/src/pages/PlanningInbox.tsx` â€” odebrat lokÃ¡lnÃ­ `ArrivalBufferBar`, pÅ™idat override handlery
- `apps/web/src/pages/PlanningInbox.module.css` â€” odebrat buffer styly (pÅ™esunuty do sdÃ­lenÃ© komponenty)
- `apps/web/src/pages/Planner.tsx` â€” pÅ™idat buffer state + `ArrivalBufferBar` + override handlery
- `apps/web/src/components/planner/RouteDetailTimeline.tsx` â€” inline editace duration + override indikÃ¡tory
- `apps/web/src/components/planner/RouteDetailTimeline.module.css` â€” styly pro inline editing
- `apps/web/src/components/planner/PlanningTimeline.tsx` â€” inline editace duration + override indikÃ¡tory
- `apps/web/src/components/planner/PlanningTimeline.module.css` â€” styly pro inline editing
- `apps/web/src/components/planner/index.ts` â€” export `ArrivalBufferBar`
- `apps/web/public/locales/{cs,en,sk}/planner.json` â€” novÃ© pÅ™eklady

---

## 7. Soubory dotÄenÃ© zmÄ›nami (fÃ¡ze 1â€“13, buffer pÅ™esun â€” HOTOVO)

### SmazanÃ© soubory
- `worker/migrations/004_add_crew_buffer.sql`
- `worker/migrations/005_fix_crew_buffer_type.sql`
- `worker/migrations/014_add_crew_fixed_buffer.sql`

### ZmÄ›nÄ›nÃ© soubory â€” backend
- `worker/migrations/001_initial_schema.sql` â€” pÅ™idat buffer do `routes`, `users`; odebrat z `crews`
- `worker/src/types/crew.rs` â€” odebrat buffer pole + opravit testy
- `worker/src/types/route.rs` â€” pÅ™idat buffer pole
- `worker/src/types/settings.rs` â€” pÅ™idat `last_arrival_buffer_*`
- `worker/src/db/queries/crew.rs` â€” odebrat buffer z dotazÅ¯
- `worker/src/db/queries/route.rs` â€” pÅ™idat buffer do upsert/select
- `worker/src/db/queries/settings.rs` â€” ÄÃ­st/zapisovat `last_arrival_buffer_*`
- `worker/src/handlers/route.rs` â€” `handle_save_route` uklÃ¡dÃ¡ buffer + aktualizuje user prefs
- `worker/src/handlers/jobs.rs` â€” neÄÃ­st buffer z crew, pÅ™ijmout v payloadu

### ZmÄ›nÄ›nÃ© soubory â€” shared types
- `packages/shared-types/src/route.ts` â€” buffer pole
- `packages/shared-types/src/settings.ts` â€” `lastArrivalBufferPercent`, `lastArrivalBufferFixedMinutes`

### ZmÄ›nÄ›nÃ© soubory â€” frontend
- `apps/web/src/services/routeService.ts` â€” buffer v `SaveRouteRequest`, `SavedRoute`
- `apps/web/src/services/crewService.ts` â€” odebrat buffer z `Crew`
- `apps/web/src/services/settingsService.ts` â€” buffer preference
- `apps/web/src/pages/Settings.tsx` â€” odebrat buffer z `CrewForm`
- `apps/web/src/pages/PlanningInbox.tsx` â€” buffer stav, flow, `ArrivalBufferBar`
- `apps/web/src/components/planner/RouteDetailTimeline.tsx` â€” (buffer odebrÃ¡n, pÅ™esunut do PlanningInbox)
- `apps/web/src/components/planner/PlanningTimeline.tsx` â€” (buffer odebrÃ¡n, pÅ™esunut do PlanningInbox)
- `apps/web/src/components/common/TimeInput.tsx` â€” dropdown time picker
- `apps/web/public/locales/{cs,en,sk}/planner.json` â€” novÃ© pÅ™eklady buffer
- `apps/web/public/locales/{cs,en,sk}/settings.json` â€” odebrat crew buffer klÃ­Äe

---

## 11. Opravy plÃ¡novÃ¡nÃ­ a slotÅ¯ (2026-02-17)

### 11.1 VÃ½chozÃ­ doba revize: 30 â†’ 60 minut

VÃ½chozÃ­ doba servisu zmÄ›nÄ›na z 30 na 60 minut ve vÅ¡ech mÃ­stech:

| Soubor | ZmÄ›na |
|---|---|
| `worker/src/defaults.rs` | `DEFAULT_SERVICE_DURATION_MINUTES: u32 = 60` |
| `apps/web/src/pages/Settings.tsx` | Fallback v formulÃ¡Å™i `\|\| 60` |
| `apps/web/src/pages/PlanningInbox.tsx` | `useState(60)` |
| `apps/web/src/components/planner/CandidateDetail.tsx` | Default prop `= 60` |

**PoznÃ¡mka:** Migrace `001_initial_schema.sql` se nemodifikovala (checksum kontrola). ExistujÃ­cÃ­ uÅ¾ivatelÃ© updatovÃ¡ni pÅ™Ã­mo v DB: `UPDATE users SET default_service_duration_minutes = 60`.

### 11.2 Sloty zarovnÃ¡ny na Ätvrthodiny

NavrhovanÃ© sloty nynÃ­ zaÄÃ­najÃ­ vÃ½hradnÄ› na celÃ© ÄtvrthodinÄ› (00, 15, 30, 45 min). PÅ™idÃ¡na funkce `ceil_quarter_hour()` do:

- `worker/src/services/insertion.rs` â€” aplikovÃ¡no na `earliest_start`
- `worker/src/services/slot_suggester.rs` â€” aplikovÃ¡no na `arrival_time` v `try_insert_at_position`

VÅ¡echny existujÃ­cÃ­ testy proÅ¡ly (18/18: 8 slot_suggester + 10 insertion).

### 11.3 Oprava pÅ™ekrÃ½vajÃ­cÃ­ch se slotÅ¯

**ProblÃ©m:** NavrhovanÃ© sloty se pÅ™ekrÃ½valy s existujÃ­cÃ­mi zastÃ¡vkami (vÄetnÄ› pauz). Backend insertion algoritmus znÃ¡ pouze customer stops (s koordinÃ¡ty pro matici), ale ne pauzy.

**Å˜eÅ¡enÃ­ (frontend post-check):**
- V `PlanningInbox.tsx` se po obdrÅ¾enÃ­ slotÅ¯ z backendu provede kontrola pÅ™ekrytÃ­ s VÅ EMI `routeStops` (vÄetnÄ› `break` typÅ¯)
- Sloty s pÅ™ekrytÃ­m se oznaÄÃ­ jako `conflict` a vyfiltrujÃ­ z vÃ½sledkÅ¯
- UÅ¾ivatel vidÃ­ pouze sloty, kterÃ© nepÅ™ekrÃ½vajÃ­ Å¾Ã¡dnou existujÃ­cÃ­ zastÃ¡vku ani pauzu

### 11.4 Oprava timeline layoutu

- `PlanningTimeline.tsx` â€” zavedena `MIN_STOP_HEIGHT = 56px` pro stop/break karty (dÅ™Ã­ve 20px)
- `PlanningTimeline.module.css` â€” odstranÄ›na `margin: 0.125rem 0` z `.gapZone` (zpÅ¯sobovala kumulativnÃ­ drift mezi hodinovou osou a obsahem)

### 11.5 Oprava VRP activity-level timing

`worker/src/services/vrp/pragmatic.rs` â€” customer stops nynÃ­ pouÅ¾Ã­vajÃ­ activity-level timing mÃ­sto stop-level timing. Å˜eÅ¡Ã­ problÃ©m, kdy co-located break + customer stop sdÃ­lely Äasy a zÃ¡kaznÃ­kovi se pÅ™iÅ™azovala nesprÃ¡vnÃ¡ (delÅ¡Ã­) doba servisu.

### 11.6 Oprava duplicitnÃ­ch tras

`worker/src/db/queries/route.rs`:
- `upsert_route` â€” vyhledÃ¡vÃ¡ existujÃ­cÃ­ trasu podle `(user_id, date)` bez ohledu na `crew_id`, takÅ¾e zmÄ›na posÃ¡dky/depa aktualizuje stÃ¡vajÃ­cÃ­ trasu mÃ­sto vytvÃ¡Å™enÃ­ novÃ©
- UPDATE klauzule nynÃ­ sprÃ¡vnÄ› aktualizuje `crew_id` a `depot_id`
- `get_route_for_date` â€” pÅ™idÃ¡no `ORDER BY updated_at DESC LIMIT 1`

---

## 12. AnalÃ½za slotovÃ© heuristiky â€” DEEP REVIEW (2026-02-17)

> **Stav:** VyÅ¾aduje refaktoring. FunkÄnÃ­ s workaroundy, ale architektura mÃ¡ systÃ©movÃ© nedostatky.

---

### 12.1 PÅ™ehled vstupnÃ­ch bodÅ¯

SystÃ©m mÃ¡ **4 nezÃ¡vislÃ© NATS handlery** pro slot-related operace:

| # | NATS Subject | Handler | Soubor | Algoritmus | Routing |
|---|---|---|---|---|---|
| 1 | `sazinka.slots.suggest` | `handle_suggest` | `slots.rs:33` | `SlotSuggester` (V1) | Mock (Euclidean) |
| 2 | `sazinka.slots.suggest.v2` | `handle_suggest_v2` | `slots.rs:450` | `calculate_insertion_positions` | **Valhalla** |
| 3 | `sazinka.route.insertion.calculate` | `handle_insertion_calculate` | `route.rs:1328` | `calculate_insertion_positions` | **Valhalla** |
| 4 | `sazinka.slots.validate` | `handle_validate` | `slots.rs:799` | Direct time checks | **Valhalla** (prev/next only) |

**PrimÃ¡rnÃ­ UI cesta (PlanningInbox):** Frontend â†’ `insertionService.calculateInsertion()` â†’ `route.insertion.calculate` (#3)

**SekundÃ¡rnÃ­ UI cesta (CallQueue schedule dialog):** Frontend â†’ `slotService.suggestSlotsV2()` â†’ `slots.suggest.v2` (#2)

**Legacy (nepouÅ¾Ã­vÃ¡no v aktuÃ¡lnÃ­m UI):** `slots.suggest` (#1)

---

### 12.2 Architektura â€” datovÃ½ tok

#### A) PrimÃ¡rnÃ­ cesta: `route.insertion.calculate` (PlanningInbox)

```
PlanningInbox.tsx
  â”‚ useEffect([selectedCandidateId])
  â”‚ Filtruje routeStops na stopType === 'customer'  â† âš  BREAKS EXCLUDED
  â”‚
  â–¼
insertionService.calculateInsertion({
  routeStops: [customer stops only],
  depot, candidate, date, workdayStart, workdayEnd
})
  â”‚
  â–¼ NATS: route.insertion.calculate
  â”‚
handle_insertion_calculate (route.rs:1328)
  â”‚ Parsing: workdayStart/End z requestu (fallback na defaults)
  â”‚ Build locations: [candidate(0), depot(1), stop0(2), stop1(3), ...]
  â”‚ âš  BUG: service_duration_minutes pro VÅ ECHNY stops = candidate_service
  â”‚         (line 1451: `service_duration_minutes: candidate_service`)
  â”‚         MitigovÃ¡no tÃ­m, Å¾e frontend posÃ­lÃ¡ departure_time (prioritnÃ­)
  â”‚
  â”œâ”€â”€ Valhalla get_matrices() â†’ NxN matrix
  â”‚   (fallback na MockRoutingService pÅ™i chybÄ›)
  â”‚
  â–¼
calculate_insertion_positions (insertion.rs:61)
  â”‚ Pro kaÅ¾dou pozici 0..N:
  â”‚   1. prev_departure = stops_meta[i-1].departure_time ?? fallback
  â”‚   2. earliest_start = ceil_quarter_hour(prev_departure + travel_from_prev)
  â”‚   3. latest_start = next_arrival - (service + travel_to_next)
  â”‚   4. status = earliest > latest ? "conflict" : slack < 15 ? "tight" : "ok"
  â”‚
  â”‚ VÃ½stup seÅ™azen podle delta_min (vzestupnÄ›)
  â”‚
  â–¼ Response: { allPositions[], bestPosition, isFeasible }
  â”‚
PlanningInbox.tsx (post-processing, lines 541-581)
  â”‚ 1. Build occupiedWindows z VÅ ECH routeStops (vÄ. breaks)
  â”‚ 2. Pro kaÅ¾dÃ½ slot z allPositions:
  â”‚      if slot overlaps any occupiedWindow â†’ status = 'conflict'
  â”‚ 3. Filter out conflict slots
  â”‚ 4. bestPosition = suggestions[0] (first non-conflict)
  â”‚
  â–¼
SlotSuggestions.tsx â€” zobrazÃ­ jen non-conflicting sloty
```

#### B) SekundÃ¡rnÃ­ cesta: `slots.suggest.v2` (multi-crew)

```
CallQueue / ScheduleDialog
  â”‚
  â–¼ NATS: slots.suggest.v2
  â”‚
handle_suggest_v2 (slots.rs:450)
  â”‚ Pro KAÅ½DOU aktivnÃ­ posÃ¡dku:
  â”‚   1. build_crew_day_stops() â† âš  EXPLICITNÄš SKIPUJE BREAKS (line 380)
  â”‚   2. Build Valhalla matrix (candidate + depot + day_stops)
  â”‚   3. calculate_insertion_positions()
  â”‚   4. SkÃ³ring: slot_score() (travel 40%, fit 25%, preference 20%, balance 15%)
  â”‚
  â–¼ Response: CrewSlotSuggestion[] seÅ™azenÃ© dle score
```

#### C) Validace: `slots.validate`

```
ScheduleDialog (ruÄnÃ­ zadÃ¡nÃ­ Äasu)
  â”‚
  â–¼ NATS: slots.validate
  â”‚
handle_validate (slots.rs:799)
  â”‚ 1. build_crew_day_stops() â† âš  SKIPUJE BREAKS
  â”‚ 2. Kontrola: overlap s existujÃ­cÃ­mi stopy (time_overlap_minutes)
  â”‚ 3. Kontrola: reachability (travel_prev â†’ candidate, candidate â†’ next)
  â”‚ 4. Kontrola: pracovnÃ­ doba
  â”‚ 5. Kontrola: day load %
  â”‚ 6. âœ… Kontrola: break window overlap (settings.break_earliest/latest)
  â”‚      Toto je JEDINÃ‰ mÃ­sto, kde se break Äas kontroluje na backendu!
  â”‚
  â–¼ Response: { feasible, warnings[], estimated_arrival, slack }
```

---

### 12.3 IdentifikovanÃ© problÃ©my (seÅ™azeno dle zÃ¡vaÅ¾nosti)

#### ğŸ”´ VYSOKÃ zÃ¡vaÅ¾nost

| # | ProblÃ©m | Detail | Stav |
|---|---------|--------|------|
| P1 | **Breaks ignorovÃ¡ny v insertion kalkulaci** | `build_crew_day_stops()` (slots.rs:380) explicitnÄ› pÅ™eskakuje `stop_type == "break"`. Frontend (PlanningInbox.tsx:519) filtruje na `stopType === 'customer'`. Insertion algoritmus nemÃ¡ Å¾Ã¡dnou informaci o blocÃ­ch obsazenÃ½ch pauzami. | âš ï¸ Workaround: frontend post-filter (occupiedWindows) |
| P2 | **Service duration bug v handle_insertion_calculate** | `route.rs:1451`: `service_duration_minutes: candidate_service` â€” vÅ¡em existujÃ­cÃ­m stopÅ¯m se pÅ™iÅ™azuje doba servisu KANDIDÃTA, ne jejich vlastnÃ­. NapÅ™. kandidÃ¡t 60 min â†’ vÅ¡echny stopy budou povaÅ¾ovÃ¡ny za 60 min. Toto ovlivÅˆuje fallback vÃ½poÄet departure_time, kdyÅ¾ frontend nepoÅ¡le departure_time. | âš ï¸ MitigovÃ¡no tÃ­m, Å¾e frontend posÃ­lÃ¡ departure_time z recalculate |
| P3 | **Å½Ã¡dnÃ½ downstream feasibility check** | Insertion heuristika kontroluje jen, zda se kandidÃ¡t vejde do mezery. NEKONTROLUJE, zda vloÅ¾enÃ­ kandidÃ¡ta (+ extra travel time) neposune downstream stopy mimo jejich time windows. UÅ¾ivatel vidÃ­ "OK" slot, ale po vloÅ¾enÃ­ se downstream stopy mohou opozdit. | âŒ Neopraveno |

#### ğŸŸ¡ STÅ˜EDNÃ zÃ¡vaÅ¾nost

| # | ProblÃ©m | Detail | Stav |
|---|---------|--------|------|
| P4 | **V1 vs V2 nekonzistence** | V1 (`slot_suggester.rs`) pouÅ¾Ã­vÃ¡ mock travel time (Euclidean), V2 (`insertion.rs`) Valhalla. V1 se stÃ¡le registruje na `slots.suggest` a mÅ¯Å¾e bÃ½t volanÃ¡ z legacy UI cest. VÃ½sledky mohou bÃ½t dramaticky odliÅ¡nÃ©. | âŒ Neopraveno (V1 je legacy) |
| P5 | **latest_start pouÅ¾Ã­vÃ¡ arrival_time jako hard deadline** | `insertion.rs:131`: `let next_deadline = next_meta.arrival_time.or(next_meta.time_window_end)`. PouÅ¾Ã­vÃ¡ optimalizovanÃ½ arrival_time dalÅ¡Ã­ho stopu jako nepÅ™ekroÄitelnÃ½ deadline. V realitÄ› ale time_window_end (= konec domluvenÃ©ho okna) je sprÃ¡vnÃ½ deadline â€” posun o nÄ›kolik minut by nemusel bÃ½t problÃ©m, pokud stÃ¡le stÃ­hÃ¡ okno. | âš ï¸ KonzervativnÃ­ â€” radÄ›ji odmÃ­tne neÅ¾ pÅ™ijme |
| P6 | **validate SKIPUJE breaks v overlap kontrole, ale kontroluje break window** | `handle_validate` kontroluje overlap pouze s `day_stops` (bez breaks, P1). Ale zÃ¡roveÅˆ kontroluje overlap se `settings.break_earliest_time/latest_time` (line 997-1011). Tyto dvÄ› kontroly jsou redundantnÃ­/nekonzistentnÃ­ â€” break v trase mÅ¯Å¾e mÃ­t jinÃ½ Äas neÅ¾ settings break window. | âš ï¸ ÄŒÃ¡steÄnÄ› mitigovÃ¡no |

#### ğŸŸ¢ NÃZKÃ zÃ¡vaÅ¾nost

| # | ProblÃ©m | Detail | Stav |
|---|---------|--------|------|
| P7 | **slack_before vÅ¾dy 0** | `insertion.rs:139`: `let slack_before = Some(0)`. Slack before se nepoÄÃ­tÃ¡, je vÅ¾dy 0. V UI i ve scoringu se zobrazuje 0. | âŒ Neopraveno |
| P8 | **Scoring funkce ignoruje slot status** | `slot_score()` v `slots.rs` nepÅ™idÃ¡vÃ¡ Å¾Ã¡dnou penalizaci pro "tight" status. Sloty s 5 min slack a 60 min slack mohou mÃ­t stejnÃ© skÃ³re, pokud majÃ­ stejnÃ½ delta_travel. | âŒ Neopraveno |

---

### 12.4 DetailnÃ­ analÃ½za â€” `calculate_insertion_positions` (insertion.rs)

```
Vstup:
  matrices: NxN Valhalla matice (distance + time)
  candidate_idx: index kandidÃ¡ta v matici (typicky 0)
  depot_idx: index depa v matici (typicky 1)
  stop_indices: indexy existujÃ­cÃ­ch stopÅ¯ v matici [2, 3, 4, ...]
  stops_meta: metadata pro kaÅ¾dÃ½ stop (name, arrival, departure, time_window, service_duration)
  candidate_service_minutes: doba servisu kandidÃ¡ta
  workday_start, workday_end: pracovnÃ­ doba

Algoritmus (pro kaÅ¾dou insert pozici i = 0..N):
  1. from = i == 0 ? depot : stop[i-1]
     to   = i >= N ? depot : stop[i]

  2. delta_km  = dist(fromâ†’candidate) + dist(candidateâ†’to) - dist(fromâ†’to)
     delta_min = time(fromâ†’candidate) + time(candidateâ†’to) - time(fromâ†’to) + service_minutes

  3. prev_departure:
     - i == 0: workday_start
     - else:   stops_meta[i-1].departure_time
                ?? (time_window_start ?? arrival_time) + service_duration  â† fallback
                ?? workday_start

  4. earliest_start = ceil_quarter_hour(prev_departure + travel_from_to_candidate)

  5. latest_start:
     - i >= N (last position): workday_end - service
     - else:   next_arrival ?? next_time_window_end ?? workday_end
               minus (service + travel_to_next)

  6. status = earliest > latest ? "conflict" : (slack < 15 ? "tight" : "ok")

  7. VÃ½sledek seÅ™azen dle delta_min vzestupnÄ› (nejmenÅ¡Ã­ objÃ­Å¾Äka = nejlepÅ¡Ã­)
```

**KlÃ­ÄovÃ© omezenÃ­:** Algoritmus je "static gap check" â€” kontroluje, zda se kandidÃ¡t vejde do existujÃ­cÃ­ mezery, aniÅ¾ by simuloval reÃ¡lnÃ½ forward pass. NepoÄÃ­tÃ¡ s tÃ­m, Å¾e vloÅ¾enÃ­ kandidÃ¡ta zmÄ›nÃ­ Äasy VÅ ECH nÃ¡sledujÃ­cÃ­ch stopÅ¯.

---

### 12.5 DoporuÄenÃ© kroky

#### KrÃ¡tkodobÃ© (hotfix) â€” âœ… ImplementovÃ¡no
- Frontend post-filter na break overlaps (PlanningInbox.tsx)

#### StÅ™ednÄ›dobÃ© (backend fix)
1. **P1 fix:** PÅ™edÃ¡vat break bloky do `calculate_insertion_positions` jako parametr `blocked_windows: Vec<(NaiveTime, NaiveTime)>`. PÅ™i vÃ½poÄtu `earliest_start` pro pozice za breakem posunout prev_departure o break duration. AlternativnÄ›: do `build_crew_day_stops()` zahrnout breaks jako pseudo-stopy bez koordinÃ¡t a v insertion.rs je zpracovat zvlÃ¡Å¡Å¥.

2. **P2 fix:** V `handle_insertion_calculate` posÃ­lat `stop.departureTime - stop.arrivalTime` jako `service_duration_minutes` (nebo pÅ™idat `serviceDurationMinutes` jako explicitnÃ­ pole do `RouteStop` v insertionService.ts).

3. **P7 fix:** SpoÄÃ­tat `slack_before = earliest_start - prev_departure - travel_from` (kolik minut je k dispozici pÅ™ed pÅ™Ã­jezdem).

#### DlouhodobÃ© (refactoring)
1. **P3 fix â€” Forward pass simulation:** Po urÄenÃ­ insertion pozice simulovat celÃ½ schedule s kandidÃ¡tem vloÅ¾enÃ½m. Porovnat downstream stopy s jejich time windows. Pokud jakÃ½koli downstream stop vypadne z okna, oznaÄit jako "tight" nebo "conflict" se zprÃ¡vou "posune zastÃ¡vku X o Y minut".

2. **Sjednotit V1 a V2:** Odebrat V1 slot_suggester (nebo ho pÅ™etvoÅ™it na thin wrapper nad `calculate_insertion_positions`). Ponechat jeden insertion algoritmus.

3. **Scoring v2:** PÅ™idat slot status do scoring funkce. "tight" by mÄ›l mÃ­t penalizaci -20, "conflict" by nemÄ›l bÃ½t v nabÃ­dce vÅ¯bec.

---

### 12.6 Soubory dotÄenÃ© slotovou heuristikou

#### Backend
| Soubor | Popis |
|---|---|
| `worker/src/services/insertion.rs` | SdÃ­lenÃ¡ insertion heuristika (`calculate_insertion_positions`) |
| `worker/src/services/slot_suggester.rs` | Legacy V1 slot suggester (`SlotSuggester`) |
| `worker/src/handlers/slots.rs` | Handlery: `handle_suggest`, `handle_suggest_v2`, `handle_validate` + helper `build_crew_day_stops` |
| `worker/src/handlers/route.rs` | Handler: `handle_insertion_calculate` + `handle_insertion_batch` |

#### Frontend
| Soubor | Popis |
|---|---|
| `apps/web/src/services/insertionService.ts` | `calculateInsertion()`, `calculateBatchInsertion()` â€” volÃ¡nÃ­ do backendu |
| `apps/web/src/services/slotService.ts` | `suggestSlots()` (V1), `suggestSlotsV2()`, `validateSlot()` |
| `apps/web/src/pages/PlanningInbox.tsx` | VolÃ¡nÃ­ insertion + post-filter breaks + display |
| `apps/web/src/components/planner/SlotSuggestions.tsx` | UI komponenta pro zobrazenÃ­ slotÅ¯ |
| `apps/web/src/components/planner/CandidateDetail.tsx` | Detail kandidÃ¡ta se sloty |
